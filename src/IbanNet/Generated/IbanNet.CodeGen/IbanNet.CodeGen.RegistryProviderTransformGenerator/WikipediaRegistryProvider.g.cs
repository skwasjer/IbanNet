// <auto-generated/>

#nullable enable

using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using IbanNet.Extensions;
using IbanNet.Registry.Patterns;

namespace IbanNet.Registry.Wikipedia;

/// <remarks>
/// Nr. of countries: 110
/// </remarks>
partial class WikipediaRegistryProvider
{
    /// <remarks>
    /// Generated from: api-result-1312145599.json<br />
    /// </remarks>
    [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
    private static partial IEnumerable<IbanCountry> Load()
    {
        // ReSharper disable CommentTypo
        // ReSharper disable StringLiteralTypo

        // Andorra
        yield return new IbanCountry("AD")
        {
            NativeName = "Andorra",
            EnglishName = "Andorra",
            Iban = new PatternDescriptor(Patterns.AD.Iban),
            Bban = new PatternDescriptor(Patterns.AD.Bban, 4),
        };

        // United Arab Emirates
        yield return new IbanCountry("AE")
        {
            NativeName = "الإمارات العربية المتحدة",
            EnglishName = "United Arab Emirates",
            Iban = new PatternDescriptor(Patterns.AE.Iban),
            Bban = new PatternDescriptor(Patterns.AE.Bban, 4),
        };

        // Albania
        yield return new IbanCountry("AL")
        {
            NativeName = "Shqipëri",
            EnglishName = "Albania",
            Iban = new PatternDescriptor(Patterns.AL.Iban),
            Bban = new PatternDescriptor(Patterns.AL.Bban, 4),
        };

        // Angola
        yield return new IbanCountry("AO")
        {
            NativeName = "Angóla",
            EnglishName = "Angola",
            Iban = new PatternDescriptor(Patterns.AO.Iban),
            Bban = new PatternDescriptor(Patterns.AO.Bban, 4),
        };

        // Austria
        yield return new IbanCountry("AT")
        {
            NativeName = "Österreich",
            EnglishName = "Austria",
            Iban = new PatternDescriptor(Patterns.AT.Iban),
            Bban = new PatternDescriptor(Patterns.AT.Bban, 4),
        };

        // Azerbaijan
        yield return new IbanCountry("AZ")
        {
            NativeName = "Азәрбајҹан",
            EnglishName = "Azerbaijan",
            Iban = new PatternDescriptor(Patterns.AZ.Iban),
            Bban = new PatternDescriptor(Patterns.AZ.Bban, 4),
        };

        // Bosnia and Herzegovina
        yield return new IbanCountry("BA")
        {
            NativeName = "Bosna i Hercegovina",
            EnglishName = "Bosnia and Herzegovina",
            Iban = new PatternDescriptor(Patterns.BA.Iban),
            Bban = new PatternDescriptor(Patterns.BA.Bban, 4),
        };

        // Belgium
        yield return new IbanCountry("BE")
        {
            NativeName = "België",
            EnglishName = "Belgium",
            Iban = new PatternDescriptor(Patterns.BE.Iban),
            Bban = new PatternDescriptor(Patterns.BE.Bban, 4),
        };

        // Burkina Faso
        yield return new IbanCountry("BF")
        {
            NativeName = "Burkibaa Faaso",
            EnglishName = "Burkina Faso",
            Iban = new PatternDescriptor(Patterns.BF.Iban),
            Bban = new PatternDescriptor(Patterns.BF.Bban, 4),
        };

        // Bulgaria
        yield return new IbanCountry("BG")
        {
            NativeName = "България",
            EnglishName = "Bulgaria",
            Iban = new PatternDescriptor(Patterns.BG.Iban),
            Bban = new PatternDescriptor(Patterns.BG.Bban, 4),
        };

        // Bahrain
        yield return new IbanCountry("BH")
        {
            NativeName = "البحرين",
            EnglishName = "Bahrain",
            Iban = new PatternDescriptor(Patterns.BH.Iban),
            Bban = new PatternDescriptor(Patterns.BH.Bban, 4),
        };

        // Burundi
        yield return new IbanCountry("BI")
        {
            NativeName = "Burundi",
            EnglishName = "Burundi",
            Iban = new PatternDescriptor(Patterns.BI.Iban),
            Bban = new PatternDescriptor(Patterns.BI.Bban, 4),
        };

        // Benin
        yield return new IbanCountry("BJ")
        {
            NativeName = "Bénin",
            EnglishName = "Benin",
            Iban = new PatternDescriptor(Patterns.BJ.Iban),
            Bban = new PatternDescriptor(Patterns.BJ.Bban, 4),
        };

        // Brazil
        yield return new IbanCountry("BR")
        {
            NativeName = "Brasil",
            EnglishName = "Brazil",
            Iban = new PatternDescriptor(Patterns.BR.Iban),
            Bban = new PatternDescriptor(Patterns.BR.Bban, 4),
        };

        // Belarus
        yield return new IbanCountry("BY")
        {
            NativeName = "Беларусь",
            EnglishName = "Belarus",
            Iban = new PatternDescriptor(Patterns.BY.Iban),
            Bban = new PatternDescriptor(Patterns.BY.Bban, 4),
        };

        // Central African Republic
        yield return new IbanCountry("CF")
        {
            NativeName = "République centrafricaine",
            EnglishName = "Central African Republic",
            Iban = new PatternDescriptor(Patterns.CF.Iban),
            Bban = new PatternDescriptor(Patterns.CF.Bban, 4),
        };

        // Congo, Republic of the
        yield return new IbanCountry("CG")
        {
            NativeName = "Congo",
            EnglishName = "Congo, Republic of the",
            Iban = new PatternDescriptor(Patterns.CG.Iban),
            Bban = new PatternDescriptor(Patterns.CG.Bban, 4),
        };

        // Switzerland
        yield return new IbanCountry("CH")
        {
            NativeName = "Svizzera",
            EnglishName = "Switzerland",
            Iban = new PatternDescriptor(Patterns.CH.Iban),
            Bban = new PatternDescriptor(Patterns.CH.Bban, 4),
        };

        // Côte d'Ivoire
        yield return new IbanCountry("CI")
        {
            NativeName = "Côte d’Ivoire",
            EnglishName = "Côte d'Ivoire",
            Iban = new PatternDescriptor(Patterns.CI.Iban),
            Bban = new PatternDescriptor(Patterns.CI.Bban, 4),
        };

        // Cameroon
        yield return new IbanCountry("CM")
        {
            NativeName = "Kàmàlûŋ",
            EnglishName = "Cameroon",
            Iban = new PatternDescriptor(Patterns.CM.Iban),
            Bban = new PatternDescriptor(Patterns.CM.Bban, 4),
        };

        // Costa Rica
        yield return new IbanCountry("CR")
        {
            NativeName = "Costa Rica",
            EnglishName = "Costa Rica",
            Iban = new PatternDescriptor(Patterns.CR.Iban),
            Bban = new PatternDescriptor(Patterns.CR.Bban, 4),
        };

        // Cabo Verde
        yield return new IbanCountry("CV")
        {
            NativeName = "Kabu Verdi",
            EnglishName = "Cabo Verde",
            Iban = new PatternDescriptor(Patterns.CV.Iban),
            Bban = new PatternDescriptor(Patterns.CV.Bban, 4),
        };

        // Cyprus
        yield return new IbanCountry("CY")
        {
            NativeName = "Κύπρος",
            EnglishName = "Cyprus",
            Iban = new PatternDescriptor(Patterns.CY.Iban),
            Bban = new PatternDescriptor(Patterns.CY.Bban, 4),
        };

        // Czech Republic
        yield return new IbanCountry("CZ")
        {
            NativeName = "Česko",
            EnglishName = "Czech Republic",
            Iban = new PatternDescriptor(Patterns.CZ.Iban),
            Bban = new PatternDescriptor(Patterns.CZ.Bban, 4),
        };

        // Germany
        yield return new IbanCountry("DE")
        {
            NativeName = "Deutschland",
            EnglishName = "Germany",
            Iban = new PatternDescriptor(Patterns.DE.Iban),
            Bban = new PatternDescriptor(Patterns.DE.Bban, 4),
        };

        // Djibouti
        yield return new IbanCountry("DJ")
        {
            NativeName = "Yabuuti",
            EnglishName = "Djibouti",
            Iban = new PatternDescriptor(Patterns.DJ.Iban),
            Bban = new PatternDescriptor(Patterns.DJ.Bban, 4),
        };

        // Denmark
        yield return new IbanCountry("DK")
        {
            NativeName = "Danmark",
            EnglishName = "Denmark",
            Iban = new PatternDescriptor(Patterns.DK.Iban),
            Bban = new PatternDescriptor(Patterns.DK.Bban, 4),
        };

        // Dominican Republic
        yield return new IbanCountry("DO")
        {
            NativeName = "República Dominicana",
            EnglishName = "Dominican Republic",
            Iban = new PatternDescriptor(Patterns.DO.Iban),
            Bban = new PatternDescriptor(Patterns.DO.Bban, 4),
        };

        // Algeria
        yield return new IbanCountry("DZ")
        {
            NativeName = "الجزائر",
            EnglishName = "Algeria",
            Iban = new PatternDescriptor(Patterns.DZ.Iban),
            Bban = new PatternDescriptor(Patterns.DZ.Bban, 4),
        };

        // Estonia
        yield return new IbanCountry("EE")
        {
            NativeName = "Eesti",
            EnglishName = "Estonia",
            Iban = new PatternDescriptor(Patterns.EE.Iban),
            Bban = new PatternDescriptor(Patterns.EE.Bban, 4),
        };

        // Egypt
        yield return new IbanCountry("EG")
        {
            NativeName = "مصر",
            EnglishName = "Egypt",
            Iban = new PatternDescriptor(Patterns.EG.Iban),
            Bban = new PatternDescriptor(Patterns.EG.Bban, 4),
        };

        // Spain
        yield return new IbanCountry("ES")
        {
            NativeName = "España",
            EnglishName = "Spain",
            Iban = new PatternDescriptor(Patterns.ES.Iban),
            Bban = new PatternDescriptor(Patterns.ES.Bban, 4),
        };

        // Finland
        yield return new IbanCountry("FI")
        {
            NativeName = "Suomi",
            EnglishName = "Finland",
            Iban = new PatternDescriptor(Patterns.FI.Iban),
            Bban = new PatternDescriptor(Patterns.FI.Bban, 4),
        };

        // Falkland Islands
        yield return new IbanCountry("FK")
        {
            NativeName = "Falkland Islands",
            EnglishName = "Falkland Islands",
            Iban = new PatternDescriptor(Patterns.FK.Iban),
            Bban = new PatternDescriptor(Patterns.FK.Bban, 4),
        };

        // Faroe Islands
        yield return new IbanCountry("FO")
        {
            NativeName = "Føroyar",
            EnglishName = "Faroe Islands",
            Iban = new PatternDescriptor(Patterns.FO.Iban),
            Bban = new PatternDescriptor(Patterns.FO.Bban, 4),
        };

        // France
        yield return new IbanCountry("FR")
        {
            NativeName = "France",
            EnglishName = "France",
            Iban = new PatternDescriptor(Patterns.FR.Iban),
            Bban = new PatternDescriptor(Patterns.FR.Bban, 4),
        };

        // Gabon
        yield return new IbanCountry("GA")
        {
            NativeName = "Gabon",
            EnglishName = "Gabon",
            Iban = new PatternDescriptor(Patterns.GA.Iban),
            Bban = new PatternDescriptor(Patterns.GA.Bban, 4),
        };

        // United Kingdom
        yield return new IbanCountry("GB")
        {
            NativeName = "United Kingdom",
            EnglishName = "United Kingdom",
            Iban = new PatternDescriptor(Patterns.GB.Iban),
            Bban = new PatternDescriptor(Patterns.GB.Bban, 4),
        };

        // Georgia
        yield return new IbanCountry("GE")
        {
            NativeName = "საქართველო",
            EnglishName = "Georgia",
            Iban = new PatternDescriptor(Patterns.GE.Iban),
            Bban = new PatternDescriptor(Patterns.GE.Bban, 4),
        };

        // Gibraltar
        yield return new IbanCountry("GI")
        {
            NativeName = "Gibraltar",
            EnglishName = "Gibraltar",
            Iban = new PatternDescriptor(Patterns.GI.Iban),
            Bban = new PatternDescriptor(Patterns.GI.Bban, 4),
        };

        // Greenland
        yield return new IbanCountry("GL")
        {
            NativeName = "Kalaallit Nunaat",
            EnglishName = "Greenland",
            Iban = new PatternDescriptor(Patterns.GL.Iban),
            Bban = new PatternDescriptor(Patterns.GL.Bban, 4),
        };

        // Equatorial Guinea
        yield return new IbanCountry("GQ")
        {
            NativeName = "Guinea Ecuatorial",
            EnglishName = "Equatorial Guinea",
            Iban = new PatternDescriptor(Patterns.GQ.Iban),
            Bban = new PatternDescriptor(Patterns.GQ.Bban, 4),
        };

        // Greece
        yield return new IbanCountry("GR")
        {
            NativeName = "Ελλάδα",
            EnglishName = "Greece",
            Iban = new PatternDescriptor(Patterns.GR.Iban),
            Bban = new PatternDescriptor(Patterns.GR.Bban, 4),
        };

        // Guatemala
        yield return new IbanCountry("GT")
        {
            NativeName = "Guatemala",
            EnglishName = "Guatemala",
            Iban = new PatternDescriptor(Patterns.GT.Iban),
            Bban = new PatternDescriptor(Patterns.GT.Bban, 4),
        };

        // Guinea-Bissau
        yield return new IbanCountry("GW")
        {
            NativeName = "Gine-Bisaawo",
            EnglishName = "Guinea-Bissau",
            Iban = new PatternDescriptor(Patterns.GW.Iban),
            Bban = new PatternDescriptor(Patterns.GW.Bban, 4),
        };

        // Honduras
        yield return new IbanCountry("HN")
        {
            NativeName = "Honduras",
            EnglishName = "Honduras",
            Iban = new PatternDescriptor(Patterns.HN.Iban),
            Bban = new PatternDescriptor(Patterns.HN.Bban, 4),
        };

        // Croatia
        yield return new IbanCountry("HR")
        {
            NativeName = "Hrvatska",
            EnglishName = "Croatia",
            Iban = new PatternDescriptor(Patterns.HR.Iban),
            Bban = new PatternDescriptor(Patterns.HR.Bban, 4),
        };

        // Hungary
        yield return new IbanCountry("HU")
        {
            NativeName = "Magyarország",
            EnglishName = "Hungary",
            Iban = new PatternDescriptor(Patterns.HU.Iban),
            Bban = new PatternDescriptor(Patterns.HU.Bban, 4),
        };

        // Ireland
        yield return new IbanCountry("IE")
        {
            NativeName = "Ireland",
            EnglishName = "Ireland",
            Iban = new PatternDescriptor(Patterns.IE.Iban),
            Bban = new PatternDescriptor(Patterns.IE.Bban, 4),
        };

        // Israel
        yield return new IbanCountry("IL")
        {
            NativeName = "ישראל",
            EnglishName = "Israel",
            Iban = new PatternDescriptor(Patterns.IL.Iban),
            Bban = new PatternDescriptor(Patterns.IL.Bban, 4),
        };

        // Iraq
        yield return new IbanCountry("IQ")
        {
            NativeName = "العراق",
            EnglishName = "Iraq",
            Iban = new PatternDescriptor(Patterns.IQ.Iban),
            Bban = new PatternDescriptor(Patterns.IQ.Bban, 4),
        };

        // Iran
        yield return new IbanCountry("IR")
        {
            NativeName = "ایران",
            EnglishName = "Iran",
            Iban = new PatternDescriptor(Patterns.IR.Iban),
            Bban = new PatternDescriptor(Patterns.IR.Bban, 4),
        };

        // Iceland
        yield return new IbanCountry("IS")
        {
            NativeName = "Ísland",
            EnglishName = "Iceland",
            Iban = new PatternDescriptor(Patterns.IS.Iban),
            Bban = new PatternDescriptor(Patterns.IS.Bban, 4),
        };

        // Italy
        yield return new IbanCountry("IT")
        {
            NativeName = "Italia",
            EnglishName = "Italy",
            Iban = new PatternDescriptor(Patterns.IT.Iban),
            Bban = new PatternDescriptor(Patterns.IT.Bban, 4),
        };

        // Jordan
        yield return new IbanCountry("JO")
        {
            NativeName = "الأردن",
            EnglishName = "Jordan",
            Iban = new PatternDescriptor(Patterns.JO.Iban),
            Bban = new PatternDescriptor(Patterns.JO.Bban, 4),
        };

        // Comoros
        yield return new IbanCountry("KM")
        {
            NativeName = "جزر القمر",
            EnglishName = "Comoros",
            Iban = new PatternDescriptor(Patterns.KM.Iban),
            Bban = new PatternDescriptor(Patterns.KM.Bban, 4),
        };

        // Kuwait
        yield return new IbanCountry("KW")
        {
            NativeName = "الكويت",
            EnglishName = "Kuwait",
            Iban = new PatternDescriptor(Patterns.KW.Iban),
            Bban = new PatternDescriptor(Patterns.KW.Bban, 4),
        };

        // Kazakhstan
        yield return new IbanCountry("KZ")
        {
            NativeName = "Қазақстан",
            EnglishName = "Kazakhstan",
            Iban = new PatternDescriptor(Patterns.KZ.Iban),
            Bban = new PatternDescriptor(Patterns.KZ.Bban, 4),
        };

        // Lebanon
        yield return new IbanCountry("LB")
        {
            NativeName = "لبنان",
            EnglishName = "Lebanon",
            Iban = new PatternDescriptor(Patterns.LB.Iban),
            Bban = new PatternDescriptor(Patterns.LB.Bban, 4),
        };

        // Saint Lucia
        yield return new IbanCountry("LC")
        {
            NativeName = "St. Lucia",
            EnglishName = "Saint Lucia",
            Iban = new PatternDescriptor(Patterns.LC.Iban),
            Bban = new PatternDescriptor(Patterns.LC.Bban, 4),
        };

        // Liechtenstein
        yield return new IbanCountry("LI")
        {
            NativeName = "Liechtenstein",
            EnglishName = "Liechtenstein",
            Iban = new PatternDescriptor(Patterns.LI.Iban),
            Bban = new PatternDescriptor(Patterns.LI.Bban, 4),
        };

        // Lithuania
        yield return new IbanCountry("LT")
        {
            NativeName = "Lietuva",
            EnglishName = "Lithuania",
            Iban = new PatternDescriptor(Patterns.LT.Iban),
            Bban = new PatternDescriptor(Patterns.LT.Bban, 4),
        };

        // Luxembourg
        yield return new IbanCountry("LU")
        {
            NativeName = "Lëtzebuerg",
            EnglishName = "Luxembourg",
            Iban = new PatternDescriptor(Patterns.LU.Iban),
            Bban = new PatternDescriptor(Patterns.LU.Bban, 4),
        };

        // Latvia
        yield return new IbanCountry("LV")
        {
            NativeName = "Latvija",
            EnglishName = "Latvia",
            Iban = new PatternDescriptor(Patterns.LV.Iban),
            Bban = new PatternDescriptor(Patterns.LV.Bban, 4),
        };

        // Libya
        yield return new IbanCountry("LY")
        {
            NativeName = "ليبيا",
            EnglishName = "Libya",
            Iban = new PatternDescriptor(Patterns.LY.Iban),
            Bban = new PatternDescriptor(Patterns.LY.Bban, 4),
        };

        // Morocco
        yield return new IbanCountry("MA")
        {
            NativeName = "المملكة المغربية",
            EnglishName = "Morocco",
            Iban = new PatternDescriptor(Patterns.MA.Iban),
            Bban = new PatternDescriptor(Patterns.MA.Bban, 4),
        };

        // Monaco
        yield return new IbanCountry("MC")
        {
            NativeName = "Monaco",
            EnglishName = "Monaco",
            Iban = new PatternDescriptor(Patterns.MC.Iban),
            Bban = new PatternDescriptor(Patterns.MC.Bban, 4),
        };

        // Moldova
        yield return new IbanCountry("MD")
        {
            NativeName = "Republica Moldova",
            EnglishName = "Moldova",
            Iban = new PatternDescriptor(Patterns.MD.Iban),
            Bban = new PatternDescriptor(Patterns.MD.Bban, 4),
        };

        // Montenegro
        yield return new IbanCountry("ME")
        {
            NativeName = "Crna Gora",
            EnglishName = "Montenegro",
            Iban = new PatternDescriptor(Patterns.ME.Iban),
            Bban = new PatternDescriptor(Patterns.ME.Bban, 4),
        };

        // Madagascar
        yield return new IbanCountry("MG")
        {
            NativeName = "Madagascar",
            EnglishName = "Madagascar",
            Iban = new PatternDescriptor(Patterns.MG.Iban),
            Bban = new PatternDescriptor(Patterns.MG.Bban, 4),
        };

        // North Macedonia
        yield return new IbanCountry("MK")
        {
            NativeName = "Северна Македонија",
            EnglishName = "North Macedonia",
            Iban = new PatternDescriptor(Patterns.MK.Iban),
            Bban = new PatternDescriptor(Patterns.MK.Bban, 4),
        };

        // Mali
        yield return new IbanCountry("ML")
        {
            NativeName = "Mali",
            EnglishName = "Mali",
            Iban = new PatternDescriptor(Patterns.ML.Iban),
            Bban = new PatternDescriptor(Patterns.ML.Bban, 4),
        };

        // Mongolia
        yield return new IbanCountry("MN")
        {
            NativeName = "Монгол",
            EnglishName = "Mongolia",
            Iban = new PatternDescriptor(Patterns.MN.Iban),
            Bban = new PatternDescriptor(Patterns.MN.Bban, 4),
        };

        // Mauritania
        yield return new IbanCountry("MR")
        {
            NativeName = "موريتانيا",
            EnglishName = "Mauritania",
            Iban = new PatternDescriptor(Patterns.MR.Iban),
            Bban = new PatternDescriptor(Patterns.MR.Bban, 4),
        };

        // Malta
        yield return new IbanCountry("MT")
        {
            NativeName = "Malta",
            EnglishName = "Malta",
            Iban = new PatternDescriptor(Patterns.MT.Iban),
            Bban = new PatternDescriptor(Patterns.MT.Bban, 4),
        };

        // Mauritius
        yield return new IbanCountry("MU")
        {
            NativeName = "Mauritius",
            EnglishName = "Mauritius",
            Iban = new PatternDescriptor(Patterns.MU.Iban),
            Bban = new PatternDescriptor(Patterns.MU.Bban, 4),
        };

        // Mozambique
        yield return new IbanCountry("MZ")
        {
            NativeName = "Umozambiki",
            EnglishName = "Mozambique",
            Iban = new PatternDescriptor(Patterns.MZ.Iban),
            Bban = new PatternDescriptor(Patterns.MZ.Bban, 4),
        };

        // Niger
        yield return new IbanCountry("NE")
        {
            NativeName = "Nižer",
            EnglishName = "Niger",
            Iban = new PatternDescriptor(Patterns.NE.Iban),
            Bban = new PatternDescriptor(Patterns.NE.Bban, 4),
        };

        // Nicaragua
        yield return new IbanCountry("NI")
        {
            NativeName = "Nicaragua",
            EnglishName = "Nicaragua",
            Iban = new PatternDescriptor(Patterns.NI.Iban),
            Bban = new PatternDescriptor(Patterns.NI.Bban, 4),
        };

        // Netherlands
        yield return new IbanCountry("NL")
        {
            NativeName = "Nederland",
            EnglishName = "Netherlands",
            Iban = new PatternDescriptor(Patterns.NL.Iban),
            Bban = new PatternDescriptor(Patterns.NL.Bban, 4),
        };

        // Norway
        yield return new IbanCountry("NO")
        {
            NativeName = "Noreg",
            EnglishName = "Norway",
            Iban = new PatternDescriptor(Patterns.NO.Iban),
            Bban = new PatternDescriptor(Patterns.NO.Bban, 4),
        };

        // Oman
        yield return new IbanCountry("OM")
        {
            NativeName = "عمان",
            EnglishName = "Oman",
            Iban = new PatternDescriptor(Patterns.OM.Iban),
            Bban = new PatternDescriptor(Patterns.OM.Bban, 4),
        };

        // Pakistan
        yield return new IbanCountry("PK")
        {
            NativeName = "پاکستان",
            EnglishName = "Pakistan",
            Iban = new PatternDescriptor(Patterns.PK.Iban),
            Bban = new PatternDescriptor(Patterns.PK.Bban, 4),
        };

        // Poland
        yield return new IbanCountry("PL")
        {
            NativeName = "Polska",
            EnglishName = "Poland",
            Iban = new PatternDescriptor(Patterns.PL.Iban),
            Bban = new PatternDescriptor(Patterns.PL.Bban, 4),
        };

        // Palestinian territories
        yield return new IbanCountry("PS")
        {
            NativeName = "السلطة الفلسطينية",
            EnglishName = "Palestinian territories",
            Iban = new PatternDescriptor(Patterns.PS.Iban),
            Bban = new PatternDescriptor(Patterns.PS.Bban, 4),
        };

        // Portugal
        yield return new IbanCountry("PT")
        {
            NativeName = "Portugal",
            EnglishName = "Portugal",
            Iban = new PatternDescriptor(Patterns.PT.Iban),
            Bban = new PatternDescriptor(Patterns.PT.Bban, 4),
        };

        // Qatar
        yield return new IbanCountry("QA")
        {
            NativeName = "قطر",
            EnglishName = "Qatar",
            Iban = new PatternDescriptor(Patterns.QA.Iban),
            Bban = new PatternDescriptor(Patterns.QA.Bban, 4),
        };

        // Romania
        yield return new IbanCountry("RO")
        {
            NativeName = "România",
            EnglishName = "Romania",
            Iban = new PatternDescriptor(Patterns.RO.Iban),
            Bban = new PatternDescriptor(Patterns.RO.Bban, 4),
        };

        // Serbia
        yield return new IbanCountry("RS")
        {
            NativeName = "Srbija",
            EnglishName = "Serbia",
            Iban = new PatternDescriptor(Patterns.RS.Iban),
            Bban = new PatternDescriptor(Patterns.RS.Bban, 4),
        };

        // Saudi Arabia
        yield return new IbanCountry("SA")
        {
            NativeName = "المملكة العربية السعودية",
            EnglishName = "Saudi Arabia",
            Iban = new PatternDescriptor(Patterns.SA.Iban),
            Bban = new PatternDescriptor(Patterns.SA.Bban, 4),
        };

        // Seychelles
        yield return new IbanCountry("SC")
        {
            NativeName = "Seychelles",
            EnglishName = "Seychelles",
            Iban = new PatternDescriptor(Patterns.SC.Iban),
            Bban = new PatternDescriptor(Patterns.SC.Bban, 4),
        };

        // Sudan
        yield return new IbanCountry("SD")
        {
            NativeName = "السودان",
            EnglishName = "Sudan",
            Iban = new PatternDescriptor(Patterns.SD.Iban),
            Bban = new PatternDescriptor(Patterns.SD.Bban, 4),
        };

        // Sweden
        yield return new IbanCountry("SE")
        {
            NativeName = "Sverige",
            EnglishName = "Sweden",
            Iban = new PatternDescriptor(Patterns.SE.Iban),
            Bban = new PatternDescriptor(Patterns.SE.Bban, 4),
        };

        // Slovenia
        yield return new IbanCountry("SI")
        {
            NativeName = "Slovenija",
            EnglishName = "Slovenia",
            Iban = new PatternDescriptor(Patterns.SI.Iban),
            Bban = new PatternDescriptor(Patterns.SI.Bban, 4),
        };

        // Slovakia
        yield return new IbanCountry("SK")
        {
            NativeName = "Slovensko",
            EnglishName = "Slovakia",
            Iban = new PatternDescriptor(Patterns.SK.Iban),
            Bban = new PatternDescriptor(Patterns.SK.Bban, 4),
        };

        // San Marino
        yield return new IbanCountry("SM")
        {
            NativeName = "San Marino",
            EnglishName = "San Marino",
            Iban = new PatternDescriptor(Patterns.SM.Iban),
            Bban = new PatternDescriptor(Patterns.SM.Bban, 4),
        };

        // Senegal
        yield return new IbanCountry("SN")
        {
            NativeName = "Senegaal",
            EnglishName = "Senegal",
            Iban = new PatternDescriptor(Patterns.SN.Iban),
            Bban = new PatternDescriptor(Patterns.SN.Bban, 4),
        };

        // Somalia
        yield return new IbanCountry("SO")
        {
            NativeName = "الصومال",
            EnglishName = "Somalia",
            Iban = new PatternDescriptor(Patterns.SO.Iban),
            Bban = new PatternDescriptor(Patterns.SO.Bban, 4),
        };

        // São Tomé and Príncipe
        yield return new IbanCountry("ST")
        {
            NativeName = "São Tomé e Príncipe",
            EnglishName = "São Tomé and Príncipe",
            Iban = new PatternDescriptor(Patterns.ST.Iban),
            Bban = new PatternDescriptor(Patterns.ST.Bban, 4),
        };

        // El Salvador
        yield return new IbanCountry("SV")
        {
            NativeName = "El Salvador",
            EnglishName = "El Salvador",
            Iban = new PatternDescriptor(Patterns.SV.Iban),
            Bban = new PatternDescriptor(Patterns.SV.Bban, 4),
        };

        // Chad
        yield return new IbanCountry("TD")
        {
            NativeName = "تشاد",
            EnglishName = "Chad",
            Iban = new PatternDescriptor(Patterns.TD.Iban),
            Bban = new PatternDescriptor(Patterns.TD.Bban, 4),
        };

        // Togo
        yield return new IbanCountry("TG")
        {
            NativeName = "Togo nutome",
            EnglishName = "Togo",
            Iban = new PatternDescriptor(Patterns.TG.Iban),
            Bban = new PatternDescriptor(Patterns.TG.Bban, 4),
        };

        // East Timor
        yield return new IbanCountry("TL")
        {
            NativeName = "Timor-Leste",
            EnglishName = "East Timor",
            Iban = new PatternDescriptor(Patterns.TL.Iban),
            Bban = new PatternDescriptor(Patterns.TL.Bban, 4),
        };

        // Tunisia
        yield return new IbanCountry("TN")
        {
            NativeName = "تونس",
            EnglishName = "Tunisia",
            Iban = new PatternDescriptor(Patterns.TN.Iban),
            Bban = new PatternDescriptor(Patterns.TN.Bban, 4),
        };

        // Turkey
        yield return new IbanCountry("TR")
        {
            NativeName = "Türkiye",
            EnglishName = "Turkey",
            Iban = new PatternDescriptor(Patterns.TR.Iban),
            Bban = new PatternDescriptor(Patterns.TR.Bban, 4),
        };

        // Ukraine
        yield return new IbanCountry("UA")
        {
            NativeName = "Україна",
            EnglishName = "Ukraine",
            Iban = new PatternDescriptor(Patterns.UA.Iban),
            Bban = new PatternDescriptor(Patterns.UA.Bban, 4),
        };

        // Vatican City
        yield return new IbanCountry("VA")
        {
            NativeName = "Città del Vaticano",
            EnglishName = "Vatican City",
            Iban = new PatternDescriptor(Patterns.VA.Iban),
            Bban = new PatternDescriptor(Patterns.VA.Bban, 4),
        };

        // Virgin Islands, British
        yield return new IbanCountry("VG")
        {
            NativeName = "British Virgin Islands",
            EnglishName = "Virgin Islands, British",
            Iban = new PatternDescriptor(Patterns.VG.Iban),
            Bban = new PatternDescriptor(Patterns.VG.Bban, 4),
        };

        // Kosovo
        yield return new IbanCountry("XK")
        {
            NativeName = "Kosovë",
            EnglishName = "Kosovo",
            Iban = new PatternDescriptor(Patterns.XK.Iban),
            Bban = new PatternDescriptor(Patterns.XK.Bban, 4),
        };

        // Yemen
        yield return new IbanCountry("YE")
        {
            NativeName = "اليمن",
            EnglishName = "Yemen",
            Iban = new PatternDescriptor(Patterns.YE.Iban),
            Bban = new PatternDescriptor(Patterns.YE.Bban, 4),
        };

        // ReSharper restore StringLiteralTypo
        // ReSharper restore CommentTypo
    }

    [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
    private static class Patterns
    {
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal class Pattern : IbanNet.Registry.Patterns.Pattern
        {
            public Pattern(string pattern, int maxLength, bool isFixedLength, PatternToken[] tokens)
                : base(pattern, maxLength, isFixedLength, tokens)
            {
            }
        }

        // Andorra
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("8n,12c", 24, true,
                    [
                        new PatternToken("AD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8n,12c", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );


        }

        // United Arab Emirates
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("3n,16n", 23, true,
                    [
                        new PatternToken("AE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3n,16n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Albania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("8n,16c", 28, true,
                    [
                        new PatternToken("AL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8n,16c", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Angola
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("21n", 25, true,
                    [
                        new PatternToken("AO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("21n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                );


        }

        // Austria
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("16n", 20, true,
                    [
                        new PatternToken("AT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("16n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Azerbaijan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,20c", 28, true,
                    [
                        new PatternToken("AZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,20c", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                );


        }

        // Bosnia and Herzegovina
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("16n", 20, true,
                    [
                        new PatternToken("BA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("16n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Belgium
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("12n", 16, true,
                    [
                        new PatternToken("BE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("12n", 12, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );


        }

        // Burkina Faso
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BF
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2c,22n", 28, true,
                    [
                        new PatternToken("BF"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'F'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2c,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Bulgaria
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,6n,8c", 22, true,
                    [
                        new PatternToken("BG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.AlphaNumeric, 8),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,6n,8c", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.AlphaNumeric, 8),
                    ]
                );


        }

        // Bahrain
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BH
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,14c", 22, true,
                    [
                        new PatternToken("BH"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'H'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,14c", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 14),
                    ]
                );


        }

        // Burundi
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("5n,5n,11n,2n", 27, true,
                    [
                        new PatternToken("BI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5n,5n,11n,2n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );


        }

        // Benin
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BJ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2c,22n", 28, true,
                    [
                        new PatternToken("BJ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'J'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2c,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Brazil
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n,1a,1c", 29, true,
                    [
                        new PatternToken("BR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n,1a,1c", 25, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 1),
                    ]
                );


        }

        // Belarus
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BY
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4c,4n,16c", 28, true,
                    [
                        new PatternToken("BY"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'Y'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4c,4n,16c", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Central African Republic
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CF
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("CF"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'F'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Congo, Republic of the
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("CG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Switzerland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CH
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("5n,12c", 21, true,
                    [
                        new PatternToken("CH"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'H'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5n,12c", 17, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );


        }

        // Côte d'Ivoire
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2a,22n", 28, true,
                    [
                        new PatternToken("CI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2a,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Cameroon
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CM
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("CM"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'M'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Costa Rica
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("18n", 22, true,
                    [
                        new PatternToken("CR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("18n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                );


        }

        // Cabo Verde
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CV
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("21n", 25, true,
                    [
                        new PatternToken("CV"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'V'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("21n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                );


        }

        // Cyprus
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CY
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("8n,16c", 28, true,
                    [
                        new PatternToken("CY"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'Y'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8n,16c", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Czech Republic
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("20n", 24, true,
                    [
                        new PatternToken("CZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("20n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Germany
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("18n", 22, true,
                    [
                        new PatternToken("DE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("18n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                );


        }

        // Djibouti
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DJ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("5n,5n,11n,2n", 27, true,
                    [
                        new PatternToken("DJ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'J'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5n,5n,11n,2n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );


        }

        // Denmark
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("14n", 18, true,
                    [
                        new PatternToken("DK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("14n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );


        }

        // Dominican Republic
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4c,20n", 28, true,
                    [
                        new PatternToken("DO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4c,20n", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Algeria
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("22n", 26, true,
                    [
                        new PatternToken("DZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("22n", 22, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Estonia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class EE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("16n", 20, true,
                    [
                        new PatternToken("EE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'E'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("16n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Egypt
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class EG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("25n", 29, true,
                    [
                        new PatternToken("EG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 25),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'E'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("25n", 25, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 25),
                    ]
                );


        }

        // Spain
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ES
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("20n", 24, true,
                    [
                        new PatternToken("ES"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'E'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("20n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Finland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("14n", 18, true,
                    [
                        new PatternToken("FI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("14n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );


        }

        // Falkland Islands
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2a,12n", 18, true,
                    [
                        new PatternToken("FK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2a,12n", 14, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );


        }

        // Faroe Islands
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("14n", 18, true,
                    [
                        new PatternToken("FO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("14n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );


        }

        // France
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("10n,11c,2n", 27, true,
                    [
                        new PatternToken("FR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("10n,11c,2n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );


        }

        // Gabon
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("GA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // United Kingdom
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GB
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,14n", 22, true,
                    [
                        new PatternToken("GB"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'B'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,14n", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );


        }

        // Georgia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2a,16n", 22, true,
                    [
                        new PatternToken("GE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2a,16n", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Gibraltar
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,15c", 23, true,
                    [
                        new PatternToken("GI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,15c", 19, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 15),
                    ]
                );


        }

        // Greenland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("14n", 18, true,
                    [
                        new PatternToken("GL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("14n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );


        }

        // Equatorial Guinea
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GQ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("GQ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'Q'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Greece
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("7n,16c", 27, true,
                    [
                        new PatternToken("GR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 7),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("7n,16c", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 7),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Guatemala
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4c,20c", 28, true,
                    [
                        new PatternToken("GT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4c,20c", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                );


        }

        // Guinea-Bissau
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GW
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2c,19n", 25, true,
                    [
                        new PatternToken("GW"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 19),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'W'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2c,19n", 21, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 19),
                    ]
                );


        }

        // Honduras
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class HN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,20n", 28, true,
                    [
                        new PatternToken("HN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'H'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,20n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Croatia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class HR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("17n", 21, true,
                    [
                        new PatternToken("HR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 17),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'H'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("17n", 17, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 17),
                    ]
                );


        }

        // Hungary
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class HU
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("24n", 28, true,
                    [
                        new PatternToken("HU"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 24),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'H'
                        && value[pos++] == 'U'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("24n", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 24),
                    ]
                );


        }

        // Ireland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,6n,8n", 22, true,
                    [
                        new PatternToken("IE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,6n,8n", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );


        }

        // Israel
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("19n", 23, true,
                    [
                        new PatternToken("IL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 19),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("19n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 19),
                    ]
                );


        }

        // Iraq
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IQ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,15n", 23, true,
                    [
                        new PatternToken("IQ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'Q'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,15n", 19, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                );


        }

        // Iran
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("22n", 26, true,
                    [
                        new PatternToken("IR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("22n", 22, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Iceland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IS
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("22n", 26, true,
                    [
                        new PatternToken("IS"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("22n", 22, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Italy
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("1a,10n,12c", 27, true,
                    [
                        new PatternToken("IT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("1a,10n,12c", 23, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );


        }

        // Jordan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class JO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,4n,18c", 30, true,
                    [
                        new PatternToken("JO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'J'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,4n,18c", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );


        }

        // Comoros
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class KM
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("KM"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'K'
                        && value[pos++] == 'M'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Kuwait
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class KW
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,22c", 30, true,
                    [
                        new PatternToken("KW"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'K'
                        && value[pos++] == 'W'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,22c", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 22),
                    ]
                );


        }

        // Kazakhstan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class KZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("3n,13c", 20, true,
                    [
                        new PatternToken("KZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'K'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3n,13c", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                );


        }

        // Lebanon
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LB
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4n,20c", 28, true,
                    [
                        new PatternToken("LB"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'B'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4n,20c", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                );


        }

        // Saint Lucia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LC
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,24c", 32, true,
                    [
                        new PatternToken("LC"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 24),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'C'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,24c", 28, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 24),
                    ]
                );


        }

        // Liechtenstein
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("5n,12c", 21, true,
                    [
                        new PatternToken("LI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5n,12c", 17, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );


        }

        // Lithuania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("16n", 20, true,
                    [
                        new PatternToken("LT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("16n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Luxembourg
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LU
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("3n,13c", 20, true,
                    [
                        new PatternToken("LU"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'U'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3n,13c", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                );


        }

        // Latvia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LV
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,13c", 21, true,
                    [
                        new PatternToken("LV"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'V'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,13c", 17, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                );


        }

        // Libya
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LY
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("21n", 25, true,
                    [
                        new PatternToken("LY"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'Y'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("21n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                );


        }

        // Morocco
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("24n", 28, true,
                    [
                        new PatternToken("MA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 24),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("24n", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 24),
                    ]
                );


        }

        // Monaco
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MC
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("10n,11c,2n", 27, true,
                    [
                        new PatternToken("MC"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'C'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("10n,11c,2n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );


        }

        // Moldova
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2c,18c", 24, true,
                    [
                        new PatternToken("MD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2c,18c", 20, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );


        }

        // Montenegro
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ME
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("18n", 22, true,
                    [
                        new PatternToken("ME"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("18n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                );


        }

        // Madagascar
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("MG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // North Macedonia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("3n,10c,2n", 19, true,
                    [
                        new PatternToken("MK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3n,10c,2n", 15, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );


        }

        // Mali
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ML
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2c,22n", 28, true,
                    [
                        new PatternToken("ML"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2c,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Mongolia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4n,12n", 20, true,
                    [
                        new PatternToken("MN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4n,12n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );


        }

        // Mauritania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("MR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Malta
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,5n,18c", 31, true,
                    [
                        new PatternToken("MT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,5n,18c", 27, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );


        }

        // Mauritius
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MU
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,19n,3a", 30, true,
                    [
                        new PatternToken("MU"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 19),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'U'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,19n,3a", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 19),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                );


        }

        // Mozambique
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("21n", 25, true,
                    [
                        new PatternToken("MZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("21n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                );


        }

        // Niger
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2a,22n", 28, true,
                    [
                        new PatternToken("NE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2a,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Nicaragua
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,20n", 28, true,
                    [
                        new PatternToken("NI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,20n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Netherlands
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,10n", 18, true,
                    [
                        new PatternToken("NL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,10n", 14, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );


        }

        // Norway
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("11n", 15, true,
                    [
                        new PatternToken("NO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("11n", 11, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                );


        }

        // Oman
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class OM
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("3n,16c", 23, true,
                    [
                        new PatternToken("OM"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'O'
                        && value[pos++] == 'M'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3n,16c", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Pakistan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,16c", 24, true,
                    [
                        new PatternToken("PK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,16c", 20, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Poland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("24n", 28, true,
                    [
                        new PatternToken("PL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 24),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("24n", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 24),
                    ]
                );


        }

        // Palestinian territories
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PS
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,21c", 29, true,
                    [
                        new PatternToken("PS"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,21c", 25, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                );


        }

        // Portugal
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("21n", 25, true,
                    [
                        new PatternToken("PT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("21n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                );


        }

        // Qatar
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class QA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,21c", 29, true,
                    [
                        new PatternToken("QA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'Q'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,21c", 25, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                );


        }

        // Romania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class RO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,16c", 24, true,
                    [
                        new PatternToken("RO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'R'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,16c", 20, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Serbia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class RS
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("18n", 22, true,
                    [
                        new PatternToken("RS"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'R'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("18n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 18),
                    ]
                );


        }

        // Saudi Arabia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2n,18c", 24, true,
                    [
                        new PatternToken("SA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2n,18c", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );


        }

        // Seychelles
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SC
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,20n,3a", 31, true,
                    [
                        new PatternToken("SC"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'C'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,20n,3a", 27, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                );


        }

        // Sudan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("14n", 18, true,
                    [
                        new PatternToken("SD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("14n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );


        }

        // Sweden
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("20n", 24, true,
                    [
                        new PatternToken("SE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("20n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Slovenia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("15n", 19, true,
                    [
                        new PatternToken("SI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("15n", 15, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                );


        }

        // Slovakia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("20n", 24, true,
                    [
                        new PatternToken("SK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("20n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // San Marino
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SM
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("1a,10n,12c", 27, true,
                    [
                        new PatternToken("SM"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'M'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("1a,10n,12c", 23, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );


        }

        // Senegal
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2a,22n", 28, true,
                    [
                        new PatternToken("SN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2a,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // Somalia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4n,3n,12n", 23, true,
                    [
                        new PatternToken("SO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4n,3n,12n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );


        }

        // São Tomé and Príncipe
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ST
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("21n", 25, true,
                    [
                        new PatternToken("ST"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("21n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 21),
                    ]
                );


        }

        // El Salvador
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SV
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,20n", 28, true,
                    [
                        new PatternToken("SV"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'V'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,20n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Chad
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("23n", 27, true,
                    [
                        new PatternToken("TD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("23n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 23),
                    ]
                );


        }

        // Togo
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("2a,22n", 28, true,
                    [
                        new PatternToken("TG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2a,22n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 22),
                    ]
                );


        }

        // East Timor
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("19n", 23, true,
                    [
                        new PatternToken("TL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 19),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("19n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 19),
                    ]
                );


        }

        // Tunisia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("20n", 24, true,
                    [
                        new PatternToken("TN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("20n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );


        }

        // Turkey
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("5n,1n,16c", 26, true,
                    [
                        new PatternToken("TR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5n,1n,16c", 22, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );


        }

        // Ukraine
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class UA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("6n,19c", 29, true,
                    [
                        new PatternToken("UA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.AlphaNumeric, 19),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'U'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("6n,19c", 25, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.AlphaNumeric, 19),
                    ]
                );


        }

        // Vatican City
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class VA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("3n,15n", 22, true,
                    [
                        new PatternToken("VA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'V'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3n,15n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                );


        }

        // Virgin Islands, British
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class VG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,16n", 24, true,
                    [
                        new PatternToken("VG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'V'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,16n", 20, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


        }

        // Kosovo
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class XK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4n,10n,2n", 20, true,
                    [
                        new PatternToken("XK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'X'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4n,10n,2n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );


        }

        // Yemen
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class YE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("4a,4n,18c", 30, true,
                    [
                        new PatternToken("YE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'Y'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4a,4n,18c", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );


        }
    }
}
