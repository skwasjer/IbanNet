// <auto-generated/>

#nullable enable

using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using IbanNet.Extensions;
using IbanNet.Registry.Patterns;

namespace IbanNet.Registry.Swift;

/// <remarks>
/// Nr. of countries: 88
/// </remarks>
partial class SwiftRegistryProvider
{
    /// <remarks>
    /// Generated from: Files\swift_iban_registry_202412.r99.txt<br />
    /// </remarks>
    [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
    private static partial IEnumerable<IbanCountry> Load()
    {
        // ReSharper disable CommentTypo
        // ReSharper disable StringLiteralTypo

        // Andorra
        yield return new IbanCountry("AD")
        {
            NativeName = "Andorra",
            EnglishName = "Andorra",
            Iban = new PatternDescriptor(Patterns.AD.Iban)
            {
                Example = "AD1200012030200359100100"
            },
            Bban = new PatternDescriptor(Patterns.AD.Bban, 4)
            {
                Example = "00012030200359100100"
            },
            Bank = new PatternDescriptor(Patterns.AD.Bank, 4)
            {
                Example = "0001"
            },
            Branch = new PatternDescriptor(Patterns.AD.Branch, 8)
            {
                Example = "2030"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "2030200359100100",
            LastUpdatedDate = new DateTimeOffset(2021, 3, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // United Arab Emirates (The)
        yield return new IbanCountry("AE")
        {
            NativeName = "الإمارات العربية المتحدة",
            EnglishName = "United Arab Emirates (The)",
            Iban = new PatternDescriptor(Patterns.AE.Iban)
            {
                Example = "AE070331234567890123456"
            },
            Bban = new PatternDescriptor(Patterns.AE.Bban, 4)
            {
                Example = "0331234567890123456"
            },
            Bank = new PatternDescriptor(Patterns.AE.Bank, 4)
            {
                Example = "033"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "1234567890123456",
            LastUpdatedDate = new DateTimeOffset(2015, 2, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2011, 10, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Albania
        yield return new IbanCountry("AL")
        {
            NativeName = "Shqipëri",
            EnglishName = "Albania",
            Iban = new PatternDescriptor(Patterns.AL.Iban)
            {
                Example = "AL47212110090000000235698741"
            },
            Bban = new PatternDescriptor(Patterns.AL.Bban, 4)
            {
                Example = "212110090000000235698741"
            },
            Bank = new PatternDescriptor(Patterns.AL.Bank, 4)
            {
                Example = "21211009"
            },
            Branch = new PatternDescriptor(Patterns.AL.Branch, 7)
            {
                Example = "1100"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0000000235698741",
            LastUpdatedDate = new DateTimeOffset(2011, 4, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2009, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Austria
        yield return new IbanCountry("AT")
        {
            NativeName = "Österreich",
            EnglishName = "Austria",
            Iban = new PatternDescriptor(Patterns.AT.Iban)
            {
                Example = "AT611904300234573201"
            },
            Bban = new PatternDescriptor(Patterns.AT.Bban, 4)
            {
                Example = "1904300234573201"
            },
            Bank = new PatternDescriptor(Patterns.AT.Bank, 4)
            {
                Example = "19043"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "BLZ 19043 Kto 234573201",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Azerbaijan
        yield return new IbanCountry("AZ")
        {
            NativeName = "Азәрбајҹан",
            EnglishName = "Azerbaijan",
            Iban = new PatternDescriptor(Patterns.AZ.Iban)
            {
                Example = "AZ21NABZ00000000137010001944"
            },
            Bban = new PatternDescriptor(Patterns.AZ.Bban, 4)
            {
                Example = "NABZ00000000137010001944"
            },
            Bank = new PatternDescriptor(Patterns.AZ.Bank, 4)
            {
                Example = "NABZ"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "NABZ00000000137010001944",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2013, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Bosnia and Herzegovina
        yield return new IbanCountry("BA")
        {
            NativeName = "Bosna i Hercegovina",
            EnglishName = "Bosnia and Herzegovina",
            Iban = new PatternDescriptor(Patterns.BA.Iban)
            {
                Example = "BA391290079401028494"
            },
            Bban = new PatternDescriptor(Patterns.BA.Bban, 4)
            {
                Example = "1990440001200279"
            },
            Bank = new PatternDescriptor(Patterns.BA.Bank, 4)
            {
                Example = "199"
            },
            Branch = new PatternDescriptor(Patterns.BA.Branch, 7)
            {
                Example = "044"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "199-044-00012002-79",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Belgium
        yield return new IbanCountry("BE")
        {
            NativeName = "België",
            EnglishName = "Belgium",
            Iban = new PatternDescriptor(Patterns.BE.Iban)
            {
                Example = "BE68539007547034"
            },
            Bban = new PatternDescriptor(Patterns.BE.Bban, 4)
            {
                Example = "539007547034"
            },
            Bank = new PatternDescriptor(Patterns.BE.Bank, 4)
            {
                Example = "539"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "BE68 5390 0754 7034",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Bulgaria
        yield return new IbanCountry("BG")
        {
            NativeName = "България",
            EnglishName = "Bulgaria",
            Iban = new PatternDescriptor(Patterns.BG.Iban)
            {
                Example = "BG80BNBG96611020345678"
            },
            Bban = new PatternDescriptor(Patterns.BG.Bban, 4)
            {
                Example = "BNBG96611020345678"
            },
            Bank = new PatternDescriptor(Patterns.BG.Bank, 4)
            {
                Example = "BNBG"
            },
            Branch = new PatternDescriptor(Patterns.BG.Branch, 8)
            {
                Example = "9661"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Bahrain
        yield return new IbanCountry("BH")
        {
            NativeName = "البحرين",
            EnglishName = "Bahrain",
            Iban = new PatternDescriptor(Patterns.BH.Iban)
            {
                Example = "BH67BMAG00001299123456"
            },
            Bban = new PatternDescriptor(Patterns.BH.Bban, 4)
            {
                Example = "BMAG00001299123456"
            },
            Bank = new PatternDescriptor(Patterns.BH.Bank, 4)
            {
                Example = "BMAG"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00001299123456",
            LastUpdatedDate = new DateTimeOffset(2012, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2012, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Burundi
        yield return new IbanCountry("BI")
        {
            NativeName = "Burundi",
            EnglishName = "Burundi",
            Iban = new PatternDescriptor(Patterns.BI.Iban)
            {
                Example = "BI4210000100010000332045181"
            },
            Bban = new PatternDescriptor(Patterns.BI.Bban, 4)
            {
                Example = "10000100010000332045181"
            },
            Bank = new PatternDescriptor(Patterns.BI.Bank, 4)
            {
                Example = "10000"
            },
            Branch = new PatternDescriptor(Patterns.BI.Branch, 9)
            {
                Example = "10001"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00003320451 81",
            LastUpdatedDate = new DateTimeOffset(2021, 10, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2021, 10, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Brazil
        yield return new IbanCountry("BR")
        {
            NativeName = "Brasil",
            EnglishName = "Brazil",
            Iban = new PatternDescriptor(Patterns.BR.Iban)
            {
                Example = "BR1800360305000010009795493C1"
            },
            Bban = new PatternDescriptor(Patterns.BR.Bban, 4)
            {
                Example = "00360305000010009795493P1"
            },
            Bank = new PatternDescriptor(Patterns.BR.Bank, 4)
            {
                Example = "00360305"
            },
            Branch = new PatternDescriptor(Patterns.BR.Branch, 12)
            {
                Example = "00001"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0009795493C1",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2013, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Republic of Belarus
        yield return new IbanCountry("BY")
        {
            NativeName = "Беларусь",
            EnglishName = "Republic of Belarus",
            Iban = new PatternDescriptor(Patterns.BY.Iban)
            {
                Example = "BY13NBRB3600900000002Z00AB00"
            },
            Bban = new PatternDescriptor(Patterns.BY.Bban, 4)
            {
                Example = "NBRB3600900000002Z00AB00"
            },
            Bank = new PatternDescriptor(Patterns.BY.Bank, 4)
            {
                Example = "NBRB"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "3600 0000 0000 0Z00 AB00",
            LastUpdatedDate = new DateTimeOffset(2024, 2, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2017, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Switzerland
        yield return new IbanCountry("CH")
        {
            NativeName = "Svizzera",
            EnglishName = "Switzerland",
            Iban = new PatternDescriptor(Patterns.CH.Iban)
            {
                Example = "CH9300762011623852957"
            },
            Bban = new PatternDescriptor(Patterns.CH.Bban, 4)
            {
                Example = "00762011623852957"
            },
            Bank = new PatternDescriptor(Patterns.CH.Bank, 4)
            {
                Example = "00762"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "762 1162-3852.957",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Costa Rica
        yield return new IbanCountry("CR")
        {
            NativeName = "Costa Rica",
            EnglishName = "Costa Rica",
            Iban = new PatternDescriptor(Patterns.CR.Iban)
            {
                Example = "CR05015202001026284066"
            },
            Bban = new PatternDescriptor(Patterns.CR.Bban, 4)
            {
                Example = "15202001026284066"
            },
            Bank = new PatternDescriptor(Patterns.CR.Bank, 4)
            {
                Example = "0152"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "02001026284066",
            LastUpdatedDate = new DateTimeOffset(2019, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2011, 6, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Cyprus
        yield return new IbanCountry("CY")
        {
            NativeName = "Κύπρος",
            EnglishName = "Cyprus",
            Iban = new PatternDescriptor(Patterns.CY.Iban)
            {
                Example = "CY17002001280000001200527600"
            },
            Bban = new PatternDescriptor(Patterns.CY.Bban, 4)
            {
                Example = "002001280000001200527600"
            },
            Bank = new PatternDescriptor(Patterns.CY.Bank, 4)
            {
                Example = "002"
            },
            Branch = new PatternDescriptor(Patterns.CY.Branch, 7)
            {
                Example = "00128"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "0000001200527600",
            LastUpdatedDate = new DateTimeOffset(2009, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Czechia
        yield return new IbanCountry("CZ")
        {
            NativeName = "Česko",
            EnglishName = "Czechia",
            Iban = new PatternDescriptor(Patterns.CZ.Iban)
            {
                Example = "CZ6508000000192000145399"
            },
            Bban = new PatternDescriptor(Patterns.CZ.Bban, 4)
            {
                Example = "08000000192000145399"
            },
            Bank = new PatternDescriptor(Patterns.CZ.Bank, 4)
            {
                Example = "0800"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "19-2000145399/0800",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Germany
        yield return new IbanCountry("DE")
        {
            NativeName = "Deutschland",
            EnglishName = "Germany",
            Iban = new PatternDescriptor(Patterns.DE.Iban)
            {
                Example = "DE89370400440532013000"
            },
            Bban = new PatternDescriptor(Patterns.DE.Bban, 4)
            {
                Example = "370400440532013000"
            },
            Bank = new PatternDescriptor(Patterns.DE.Bank, 4)
            {
                Example = "37040044"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "532013000",
            LastUpdatedDate = new DateTimeOffset(2011, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Djibouti
        yield return new IbanCountry("DJ")
        {
            NativeName = "Yabuuti",
            EnglishName = "Djibouti",
            Iban = new PatternDescriptor(Patterns.DJ.Iban)
            {
                Example = "DJ2100010000000154000100186"
            },
            Bban = new PatternDescriptor(Patterns.DJ.Bban, 4)
            {
                Example = "00010000000154000100186"
            },
            Bank = new PatternDescriptor(Patterns.DJ.Bank, 4)
            {
                Example = "00010"
            },
            Branch = new PatternDescriptor(Patterns.DJ.Branch, 9)
            {
                Example = "00000"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0154000100186",
            LastUpdatedDate = new DateTimeOffset(2022, 5, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2022, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Denmark
        yield return new IbanCountry("DK")
        {
            NativeName = "Danmark",
            EnglishName = "Denmark",
            Iban = new PatternDescriptor(Patterns.DK.Iban)
            {
                Example = "DK5000400440116243"
            },
            Bban = new PatternDescriptor(Patterns.DK.Bban, 4)
            {
                Example = "00400440116243"
            },
            Bank = new PatternDescriptor(Patterns.DK.Bank, 4)
            {
                Example = "0040"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "0040 0440116243",
            LastUpdatedDate = new DateTimeOffset(2018, 11, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Dominican Republic
        yield return new IbanCountry("DO")
        {
            NativeName = "República Dominicana",
            EnglishName = "Dominican Republic",
            Iban = new PatternDescriptor(Patterns.DO.Iban)
            {
                Example = "DO28BAGR00000001212453611324"
            },
            Bban = new PatternDescriptor(Patterns.DO.Bban, 4)
            {
                Example = "BAGR00000001212453611324"
            },
            Bank = new PatternDescriptor(Patterns.DO.Bank, 4)
            {
                Example = "BAGR"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00000001212453611324",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2010, 12, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Estonia
        yield return new IbanCountry("EE")
        {
            NativeName = "Eesti",
            EnglishName = "Estonia",
            Iban = new PatternDescriptor(Patterns.EE.Iban)
            {
                Example = "EE382200221020145685"
            },
            Bban = new PatternDescriptor(Patterns.EE.Bban, 4)
            {
                Example = "2200221020145685"
            },
            Bank = new PatternDescriptor(Patterns.EE.Bank, 4)
            {
                Example = "22"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "221020145685",
            LastUpdatedDate = new DateTimeOffset(2024, 12, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Egypt
        yield return new IbanCountry("EG")
        {
            NativeName = "مصر",
            EnglishName = "Egypt",
            Iban = new PatternDescriptor(Patterns.EG.Iban)
            {
                Example = "EG380019000500000000263180002"
            },
            Bban = new PatternDescriptor(Patterns.EG.Bban, 4)
            {
                Example = "0019000500000000263180002"
            },
            Bank = new PatternDescriptor(Patterns.EG.Bank, 4)
            {
                Example = "0019"
            },
            Branch = new PatternDescriptor(Patterns.EG.Branch, 8)
            {
                Example = "0005"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "000263180002",
            LastUpdatedDate = new DateTimeOffset(2020, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2021, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Spain
        yield return new IbanCountry("ES")
        {
            NativeName = "España",
            EnglishName = "Spain",
            Iban = new PatternDescriptor(Patterns.ES.Iban)
            {
                Example = "ES9121000418450200051332"
            },
            Bban = new PatternDescriptor(Patterns.ES.Bban, 4)
            {
                Example = "21000418450200051332"
            },
            Bank = new PatternDescriptor(Patterns.ES.Bank, 4)
            {
                Example = "2100"
            },
            Branch = new PatternDescriptor(Patterns.ES.Branch, 8)
            {
                Example = "0418"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "2100 0418 45 0200051332",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Finland
        yield return new IbanCountry("FI")
        {
            NativeName = "Suomi",
            EnglishName = "Finland",
            IncludedCountries = ["AX"],
            Iban = new PatternDescriptor(Patterns.FI.Iban)
            {
                Example = "FI2112345600000785"
            },
            Bban = new PatternDescriptor(Patterns.FI.Bban, 4)
            {
                Example = "12345600000785"
            },
            Bank = new PatternDescriptor(Patterns.FI.Bank, 4)
            {
                Example = "123456"
            },
            Sepa = new SepaInfo
            {
                IsMember = true,
                IncludedCountries = ["AX"]
            },
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2011, 12, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Falkland Islands
        yield return new IbanCountry("FK")
        {
            NativeName = "Falkland Islands",
            EnglishName = "Falkland Islands",
            Iban = new PatternDescriptor(Patterns.FK.Iban)
            {
                Example = "FK88SC123456789012"
            },
            Bban = new PatternDescriptor(Patterns.FK.Bban, 4)
            {
                Example = "SC123456789012"
            },
            Bank = new PatternDescriptor(Patterns.FK.Bank, 4)
            {
                Example = "SC"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "123456789012",
            LastUpdatedDate = new DateTimeOffset(2023, 7, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2023, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Faroe Islands
        yield return new IbanCountry("FO")
        {
            NativeName = "Føroyar",
            EnglishName = "Faroe Islands",
            Iban = new PatternDescriptor(Patterns.FO.Iban)
            {
                Example = "FO6264600001631634"
            },
            Bban = new PatternDescriptor(Patterns.FO.Bban, 4)
            {
                Example = "64600001631634"
            },
            Bank = new PatternDescriptor(Patterns.FO.Bank, 4)
            {
                Example = "6460"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "6460 0001631634",
            LastUpdatedDate = new DateTimeOffset(2017, 2, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // France
        yield return new IbanCountry("FR")
        {
            NativeName = "France",
            EnglishName = "France",
            IncludedCountries = ["GF", "GP", "MQ", "RE", "PF", "TF", "YT", "NC", "BL", "MF", "PM", "WF"],
            Iban = new PatternDescriptor(Patterns.FR.Iban)
            {
                Example = "FR1420041010050500013M02606"
            },
            Bban = new PatternDescriptor(Patterns.FR.Bban, 4)
            {
                Example = "20041010050500013M02606"
            },
            Bank = new PatternDescriptor(Patterns.FR.Bank, 4)
            {
                Example = "20041"
            },
            Branch = new PatternDescriptor(Patterns.FR.Branch, 9)
            {
                Example = "01005"
            },
            Sepa = new SepaInfo
            {
                IsMember = true,
                IncludedCountries = ["GF", "GP", "MQ", "YT", "RE", "PM", "BL", "MF"]
            },
            DomesticAccountNumberExample = "20041 01005 0500013M026 06",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // United Kingdom
        yield return new IbanCountry("GB")
        {
            NativeName = "United Kingdom",
            EnglishName = "United Kingdom",
            IncludedCountries = ["IM", "JE", "GG"],
            Iban = new PatternDescriptor(Patterns.GB.Iban)
            {
                Example = "GB29NWBK60161331926819"
            },
            Bban = new PatternDescriptor(Patterns.GB.Bban, 4)
            {
                Example = "NWBK60161331926819"
            },
            Bank = new PatternDescriptor(Patterns.GB.Bank, 4)
            {
                Example = "NWBK"
            },
            Branch = new PatternDescriptor(Patterns.GB.Branch, 8)
            {
                Example = "601613"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "60-16-13 31926819",
            LastUpdatedDate = new DateTimeOffset(2017, 5, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Georgia
        yield return new IbanCountry("GE")
        {
            NativeName = "საქართველო",
            EnglishName = "Georgia",
            Iban = new PatternDescriptor(Patterns.GE.Iban)
            {
                Example = "GE29NB0000000101904917"
            },
            Bban = new PatternDescriptor(Patterns.GE.Bban, 4)
            {
                Example = "NB0000000101904917"
            },
            Bank = new PatternDescriptor(Patterns.GE.Bank, 4)
            {
                Example = "NB"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0000000101904917",
            LastUpdatedDate = new DateTimeOffset(2023, 4, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2010, 5, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Gibraltar
        yield return new IbanCountry("GI")
        {
            NativeName = "Gibraltar",
            EnglishName = "Gibraltar",
            Iban = new PatternDescriptor(Patterns.GI.Iban)
            {
                Example = "GI75NWBK000000007099453"
            },
            Bban = new PatternDescriptor(Patterns.GI.Bban, 4)
            {
                Example = "NWBK000000007099453"
            },
            Bank = new PatternDescriptor(Patterns.GI.Bank, 4)
            {
                Example = "NWBK"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "0000 00007099 453",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Greenland
        yield return new IbanCountry("GL")
        {
            NativeName = "Kalaallit Nunaat",
            EnglishName = "Greenland",
            Iban = new PatternDescriptor(Patterns.GL.Iban)
            {
                Example = "GL8964710001000206"
            },
            Bban = new PatternDescriptor(Patterns.GL.Bban, 4)
            {
                Example = "64710001000206"
            },
            Bank = new PatternDescriptor(Patterns.GL.Bank, 4)
            {
                Example = "6471"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "6471 0001000206",
            LastUpdatedDate = new DateTimeOffset(2017, 2, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Greece
        yield return new IbanCountry("GR")
        {
            NativeName = "Ελλάδα",
            EnglishName = "Greece",
            Iban = new PatternDescriptor(Patterns.GR.Iban)
            {
                Example = "GR1601101250000000012300695"
            },
            Bban = new PatternDescriptor(Patterns.GR.Bban, 4)
            {
                Example = "01101250000000012300695"
            },
            Bank = new PatternDescriptor(Patterns.GR.Bank, 4)
            {
                Example = "011"
            },
            Branch = new PatternDescriptor(Patterns.GR.Branch, 7)
            {
                Example = "0125"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "01250000000012300695",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Guatemala
        yield return new IbanCountry("GT")
        {
            NativeName = "Guatemala",
            EnglishName = "Guatemala",
            Iban = new PatternDescriptor(Patterns.GT.Iban)
            {
                Example = "GT82TRAJ01020000001210029690"
            },
            Bban = new PatternDescriptor(Patterns.GT.Bban, 4)
            {
                Example = "TRAJ01020000001210029690"
            },
            Bank = new PatternDescriptor(Patterns.GT.Bank, 4)
            {
                Example = "TRAJ"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "01020000001210029690",
            LastUpdatedDate = new DateTimeOffset(2016, 10, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Honduras
        yield return new IbanCountry("HN")
        {
            NativeName = "Honduras",
            EnglishName = "Honduras",
            Iban = new PatternDescriptor(Patterns.HN.Iban)
            {
                Example = "HN88CABF00000000000250005469"
            },
            Bban = new PatternDescriptor(Patterns.HN.Bban, 4)
            {
                Example = "CABF00000000000250005469"
            },
            Bank = new PatternDescriptor(Patterns.HN.Bank, 4)
            {
                Example = "CABF"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "250005469",
            LastUpdatedDate = new DateTimeOffset(2024, 12, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2024, 10, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Croatia
        yield return new IbanCountry("HR")
        {
            NativeName = "Hrvatska",
            EnglishName = "Croatia",
            Iban = new PatternDescriptor(Patterns.HR.Iban)
            {
                Example = "HR1210010051863000160"
            },
            Bban = new PatternDescriptor(Patterns.HR.Bban, 4)
            {
                Example = "10010051863000160"
            },
            Bank = new PatternDescriptor(Patterns.HR.Bank, 4)
            {
                Example = "1001005"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "1001005-1863000160",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Hungary
        yield return new IbanCountry("HU")
        {
            NativeName = "Magyarország",
            EnglishName = "Hungary",
            Iban = new PatternDescriptor(Patterns.HU.Iban)
            {
                Example = "HU42117730161111101800000000"
            },
            Bban = new PatternDescriptor(Patterns.HU.Bban, 4)
            {
                Example = "117730161111101800000000"
            },
            Bank = new PatternDescriptor(Patterns.HU.Bank, 4)
            {
                Example = "117"
            },
            Branch = new PatternDescriptor(Patterns.HU.Branch, 7)
            {
                Example = "7301"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "11773016-11111018-00000000",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Ireland
        yield return new IbanCountry("IE")
        {
            NativeName = "Ireland",
            EnglishName = "Ireland",
            Iban = new PatternDescriptor(Patterns.IE.Iban)
            {
                Example = "IE29AIBK93115212345678"
            },
            Bban = new PatternDescriptor(Patterns.IE.Bban, 4)
            {
                Example = "AIBK93115212345678"
            },
            Bank = new PatternDescriptor(Patterns.IE.Bank, 4)
            {
                Example = "AIBK"
            },
            Branch = new PatternDescriptor(Patterns.IE.Branch, 8)
            {
                Example = "931152"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "93-11-52 12345678",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Israel
        yield return new IbanCountry("IL")
        {
            NativeName = "ישראל",
            EnglishName = "Israel",
            Iban = new PatternDescriptor(Patterns.IL.Iban)
            {
                Example = "IL620108000000099999999"
            },
            Bban = new PatternDescriptor(Patterns.IL.Bban, 4)
            {
                Example = "010800000099999999"
            },
            Bank = new PatternDescriptor(Patterns.IL.Bank, 4)
            {
                Example = "010"
            },
            Branch = new PatternDescriptor(Patterns.IL.Branch, 7)
            {
                Example = "800"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "10-800-99999999",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Iraq
        yield return new IbanCountry("IQ")
        {
            NativeName = "العراق",
            EnglishName = "Iraq",
            Iban = new PatternDescriptor(Patterns.IQ.Iban)
            {
                Example = "IQ98NBIQ850123456789012"
            },
            Bban = new PatternDescriptor(Patterns.IQ.Bban, 4)
            {
                Example = "NBIQ850123456789012"
            },
            Bank = new PatternDescriptor(Patterns.IQ.Bank, 4)
            {
                Example = "NBIQ"
            },
            Branch = new PatternDescriptor(Patterns.IQ.Branch, 8)
            {
                Example = "850"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "123456789012",
            LastUpdatedDate = new DateTimeOffset(2016, 11, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2017, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Iceland
        yield return new IbanCountry("IS")
        {
            NativeName = "Ísland",
            EnglishName = "Iceland",
            Iban = new PatternDescriptor(Patterns.IS.Iban)
            {
                Example = "IS140159260076545510730339"
            },
            Bban = new PatternDescriptor(Patterns.IS.Bban, 4)
            {
                Example = "0159260076545510730339"
            },
            Bank = new PatternDescriptor(Patterns.IS.Bank, 4)
            {
                Example = "01"
            },
            Branch = new PatternDescriptor(Patterns.IS.Branch, 6)
            {
                Example = "59"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "0159-26-007654-551073-0339",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Italy
        yield return new IbanCountry("IT")
        {
            NativeName = "Italia",
            EnglishName = "Italy",
            Iban = new PatternDescriptor(Patterns.IT.Iban)
            {
                Example = "IT60X0542811101000000123456"
            },
            Bban = new PatternDescriptor(Patterns.IT.Bban, 4)
            {
                Example = "X0542811101000000123456"
            },
            Bank = new PatternDescriptor(Patterns.IT.Bank, 5)
            {
                Example = "05428"
            },
            Branch = new PatternDescriptor(Patterns.IT.Branch, 10)
            {
                Example = "11101"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "X 05428 11101 000000123456",
            LastUpdatedDate = new DateTimeOffset(2013, 3, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Jordan
        yield return new IbanCountry("JO")
        {
            NativeName = "الأردن",
            EnglishName = "Jordan",
            Iban = new PatternDescriptor(Patterns.JO.Iban)
            {
                Example = "JO94CBJO0010000000000131000302"
            },
            Bban = new PatternDescriptor(Patterns.JO.Bban, 4)
            {
                Example = "CBJO0010000000000131000302"
            },
            Bank = new PatternDescriptor(Patterns.JO.Bank, 8)
            {
                Example = "CBJO"
            },
            Branch = new PatternDescriptor(Patterns.JO.Branch, 8),
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0001310000302",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2014, 2, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Kuwait
        yield return new IbanCountry("KW")
        {
            NativeName = "الكويت",
            EnglishName = "Kuwait",
            Iban = new PatternDescriptor(Patterns.KW.Iban)
            {
                Example = "KW81CBKU0000000000001234560101"
            },
            Bban = new PatternDescriptor(Patterns.KW.Bban, 4)
            {
                Example = "CBKU0000000000001234560101"
            },
            Bank = new PatternDescriptor(Patterns.KW.Bank, 4)
            {
                Example = "CBKU"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "1234560101",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2011, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Kazakhstan
        yield return new IbanCountry("KZ")
        {
            NativeName = "Қазақстан",
            EnglishName = "Kazakhstan",
            Iban = new PatternDescriptor(Patterns.KZ.Iban)
            {
                Example = "KZ86125KZT5004100100"
            },
            Bban = new PatternDescriptor(Patterns.KZ.Bban, 4)
            {
                Example = "125KZT5004100100"
            },
            Bank = new PatternDescriptor(Patterns.KZ.Bank, 4)
            {
                Example = "125"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "KZ86 125K ZT50 0410 0100",
            LastUpdatedDate = new DateTimeOffset(2016, 3, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2010, 9, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Lebanon
        yield return new IbanCountry("LB")
        {
            NativeName = "لبنان",
            EnglishName = "Lebanon",
            Iban = new PatternDescriptor(Patterns.LB.Iban)
            {
                Example = "LB62099900000001001901229114"
            },
            Bban = new PatternDescriptor(Patterns.LB.Bban, 4)
            {
                Example = "099900000001001901229114"
            },
            Bank = new PatternDescriptor(Patterns.LB.Bank, 4)
            {
                Example = "0999"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "01 001 901229114",
            LastUpdatedDate = new DateTimeOffset(2010, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2010, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Saint Lucia
        yield return new IbanCountry("LC")
        {
            NativeName = "St. Lucia",
            EnglishName = "Saint Lucia",
            Iban = new PatternDescriptor(Patterns.LC.Iban)
            {
                Example = "LC55HEMM000100010012001200023015"
            },
            Bban = new PatternDescriptor(Patterns.LC.Bban, 4)
            {
                Example = "HEMM000100010012001200023015"
            },
            Bank = new PatternDescriptor(Patterns.LC.Bank, 4)
            {
                Example = "HEMM"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0001 0001 0012 0012 0002 3015",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Liechtenstein
        yield return new IbanCountry("LI")
        {
            NativeName = "Liechtenstein",
            EnglishName = "Liechtenstein",
            Iban = new PatternDescriptor(Patterns.LI.Iban)
            {
                Example = "LI21088100002324013AA"
            },
            Bban = new PatternDescriptor(Patterns.LI.Bban, 4)
            {
                Example = "088100002324013AA"
            },
            Bank = new PatternDescriptor(Patterns.LI.Bank, 4)
            {
                Example = "08810"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "8810 2324013AA",
            LastUpdatedDate = new DateTimeOffset(2012, 4, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Lithuania
        yield return new IbanCountry("LT")
        {
            NativeName = "Lietuva",
            EnglishName = "Lithuania",
            Iban = new PatternDescriptor(Patterns.LT.Iban)
            {
                Example = "LT121000011101001000"
            },
            Bban = new PatternDescriptor(Patterns.LT.Bban, 4)
            {
                Example = "1000011101001000"
            },
            Bank = new PatternDescriptor(Patterns.LT.Bank, 4)
            {
                Example = "10000"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Luxembourg
        yield return new IbanCountry("LU")
        {
            NativeName = "Lëtzebuerg",
            EnglishName = "Luxembourg",
            Iban = new PatternDescriptor(Patterns.LU.Iban)
            {
                Example = "LU280019400644750000"
            },
            Bban = new PatternDescriptor(Patterns.LU.Bban, 4)
            {
                Example = "0019400644750000"
            },
            Bank = new PatternDescriptor(Patterns.LU.Bank, 4)
            {
                Example = "001"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Latvia
        yield return new IbanCountry("LV")
        {
            NativeName = "Latvija",
            EnglishName = "Latvia",
            Iban = new PatternDescriptor(Patterns.LV.Iban)
            {
                Example = "LV80BANK0000435195001"
            },
            Bban = new PatternDescriptor(Patterns.LV.Bban, 4)
            {
                Example = "BANK0000435195001"
            },
            Bank = new PatternDescriptor(Patterns.LV.Bank, 4)
            {
                Example = "BANK"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "LV80 BANK 0000 4351 9500 1",
            LastUpdatedDate = new DateTimeOffset(2009, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Libya
        yield return new IbanCountry("LY")
        {
            NativeName = "ليبيا",
            EnglishName = "Libya",
            Iban = new PatternDescriptor(Patterns.LY.Iban)
            {
                Example = "LY83002048000020100120361"
            },
            Bban = new PatternDescriptor(Patterns.LY.Bban, 4)
            {
                Example = "002048000020100120361"
            },
            Bank = new PatternDescriptor(Patterns.LY.Bank, 4)
            {
                Example = "002"
            },
            Branch = new PatternDescriptor(Patterns.LY.Branch, 7)
            {
                Example = "048"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "000020100120361",
            LastUpdatedDate = new DateTimeOffset(2020, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2021, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Monaco
        yield return new IbanCountry("MC")
        {
            NativeName = "Monaco",
            EnglishName = "Monaco",
            Iban = new PatternDescriptor(Patterns.MC.Iban)
            {
                Example = "MC5811222000010123456789030"
            },
            Bban = new PatternDescriptor(Patterns.MC.Bban, 4)
            {
                Example = "11222000010123456789030"
            },
            Bank = new PatternDescriptor(Patterns.MC.Bank, 4)
            {
                Example = "11222"
            },
            Branch = new PatternDescriptor(Patterns.MC.Branch, 9)
            {
                Example = "00001"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "0011111000h",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2008, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Moldova
        yield return new IbanCountry("MD")
        {
            NativeName = "Republica Moldova",
            EnglishName = "Moldova",
            Iban = new PatternDescriptor(Patterns.MD.Iban)
            {
                Example = "MD24AG000225100013104168"
            },
            Bban = new PatternDescriptor(Patterns.MD.Bban, 4)
            {
                Example = "AG000225100013104168"
            },
            Bank = new PatternDescriptor(Patterns.MD.Bank, 4)
            {
                Example = "AG"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "000225100013104168",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2016, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Montenegro
        yield return new IbanCountry("ME")
        {
            NativeName = "Crna Gora",
            EnglishName = "Montenegro",
            Iban = new PatternDescriptor(Patterns.ME.Iban)
            {
                Example = "ME25505000012345678951"
            },
            Bban = new PatternDescriptor(Patterns.ME.Bban, 4)
            {
                Example = "505000012345678951"
            },
            Bank = new PatternDescriptor(Patterns.ME.Bank, 4)
            {
                Example = "505"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "505 0000123456789 51",
            LastUpdatedDate = new DateTimeOffset(2010, 5, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Macedonia
        yield return new IbanCountry("MK")
        {
            NativeName = "Северна Македонија",
            EnglishName = "Macedonia",
            Iban = new PatternDescriptor(Patterns.MK.Iban)
            {
                Example = "MK07250120000058984"
            },
            Bban = new PatternDescriptor(Patterns.MK.Bban, 4)
            {
                Example = "250120000058984"
            },
            Bank = new PatternDescriptor(Patterns.MK.Bank, 4)
            {
                Example = "300"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "MK07 300 0000000424 25",
            LastUpdatedDate = new DateTimeOffset(2011, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Mongolia
        yield return new IbanCountry("MN")
        {
            NativeName = "Монгол",
            EnglishName = "Mongolia",
            Iban = new PatternDescriptor(Patterns.MN.Iban)
            {
                Example = "MN121234123456789123"
            },
            Bban = new PatternDescriptor(Patterns.MN.Bban, 4)
            {
                Example = "1234123456789123"
            },
            Bank = new PatternDescriptor(Patterns.MN.Bank, 4)
            {
                Example = "1234"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "1234 5678 9123",
            LastUpdatedDate = new DateTimeOffset(2023, 4, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2023, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Mauritania
        yield return new IbanCountry("MR")
        {
            NativeName = "موريتانيا",
            EnglishName = "Mauritania",
            Iban = new PatternDescriptor(Patterns.MR.Iban)
            {
                Example = "MR1300020001010000123456753"
            },
            Bban = new PatternDescriptor(Patterns.MR.Bban, 4)
            {
                Example = "00020001010000123456753"
            },
            Bank = new PatternDescriptor(Patterns.MR.Bank, 4)
            {
                Example = "00020"
            },
            Branch = new PatternDescriptor(Patterns.MR.Branch, 9)
            {
                Example = "00101"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00020 00101 00001234567 53",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2012, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Malta
        yield return new IbanCountry("MT")
        {
            NativeName = "Malta",
            EnglishName = "Malta",
            Iban = new PatternDescriptor(Patterns.MT.Iban)
            {
                Example = "MT84MALT011000012345MTLCAST001S"
            },
            Bban = new PatternDescriptor(Patterns.MT.Bban, 4)
            {
                Example = "MALT011000012345MTLCAST001S"
            },
            Bank = new PatternDescriptor(Patterns.MT.Bank, 4)
            {
                Example = "MALT"
            },
            Branch = new PatternDescriptor(Patterns.MT.Branch, 8)
            {
                Example = "01100"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "12345MTLCAST001S",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Mauritius
        yield return new IbanCountry("MU")
        {
            NativeName = "Mauritius",
            EnglishName = "Mauritius",
            Iban = new PatternDescriptor(Patterns.MU.Iban)
            {
                Example = "MU17BOMM0101101030300200000MUR"
            },
            Bban = new PatternDescriptor(Patterns.MU.Bban, 4)
            {
                Example = "BOMM0101101030300200000MUR"
            },
            Bank = new PatternDescriptor(Patterns.MU.Bank, 4)
            {
                Example = "BOMM01"
            },
            Branch = new PatternDescriptor(Patterns.MU.Branch, 10)
            {
                Example = "01"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "MU17 BOMM 0101 1010 3030 0200 000M UR",
            LastUpdatedDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Nicaragua
        yield return new IbanCountry("NI")
        {
            NativeName = "Nicaragua",
            EnglishName = "Nicaragua",
            Iban = new PatternDescriptor(Patterns.NI.Iban)
            {
                Example = "NI45BAPR00000013000003558124"
            },
            Bban = new PatternDescriptor(Patterns.NI.Bban, 4)
            {
                Example = "BAPR00000013000003558124"
            },
            Bank = new PatternDescriptor(Patterns.NI.Bank, 4)
            {
                Example = "BAPR"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00000013000003558124",
            LastUpdatedDate = new DateTimeOffset(2024, 12, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2023, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Netherlands (The)
        yield return new IbanCountry("NL")
        {
            NativeName = "Nederland",
            EnglishName = "Netherlands (The)",
            Iban = new PatternDescriptor(Patterns.NL.Iban)
            {
                Example = "NL91ABNA0417164300"
            },
            Bban = new PatternDescriptor(Patterns.NL.Bban, 4)
            {
                Example = "ABNA0417164300"
            },
            Bank = new PatternDescriptor(Patterns.NL.Bank, 4)
            {
                Example = "ABNA"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "041 71 64 300",
            LastUpdatedDate = new DateTimeOffset(2020, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Norway
        yield return new IbanCountry("NO")
        {
            NativeName = "Noreg",
            EnglishName = "Norway",
            Iban = new PatternDescriptor(Patterns.NO.Iban)
            {
                Example = "NO9386011117947"
            },
            Bban = new PatternDescriptor(Patterns.NO.Bban, 4)
            {
                Example = "86011117947"
            },
            Bank = new PatternDescriptor(Patterns.NO.Bank, 4)
            {
                Example = "8601"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "8601 11 17947",
            LastUpdatedDate = new DateTimeOffset(2009, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Oman
        yield return new IbanCountry("OM")
        {
            NativeName = "عمان",
            EnglishName = "Oman",
            Iban = new PatternDescriptor(Patterns.OM.Iban)
            {
                Example = "OM810180000001299123456"
            },
            Bban = new PatternDescriptor(Patterns.OM.Bban, 4)
            {
                Example = "0180000001299123456"
            },
            Bank = new PatternDescriptor(Patterns.OM.Bank, 4)
            {
                Example = "018"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0000001299123456",
            LastUpdatedDate = new DateTimeOffset(2024, 2, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2024, 3, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Pakistan
        yield return new IbanCountry("PK")
        {
            NativeName = "پاکستان",
            EnglishName = "Pakistan",
            Iban = new PatternDescriptor(Patterns.PK.Iban)
            {
                Example = "PK36SCBL0000001123456702"
            },
            Bban = new PatternDescriptor(Patterns.PK.Bban, 4)
            {
                Example = "SCBL0000001123456702"
            },
            Bank = new PatternDescriptor(Patterns.PK.Bank, 4)
            {
                Example = "SCBL"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00260101036360",
            LastUpdatedDate = new DateTimeOffset(2012, 12, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2012, 12, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Poland
        yield return new IbanCountry("PL")
        {
            NativeName = "Polska",
            EnglishName = "Poland",
            Iban = new PatternDescriptor(Patterns.PL.Iban)
            {
                Example = "PL61109010140000071219812874"
            },
            Bban = new PatternDescriptor(Patterns.PL.Bban, 4)
            {
                Example = "109010140000071219812874"
            },
            Branch = new PatternDescriptor(Patterns.PL.Branch, 4)
            {
                Example = "10901014"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "61 1090 1014 0000 0712 1981 2874",
            LastUpdatedDate = new DateTimeOffset(2016, 10, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Palestine, State of
        yield return new IbanCountry("PS")
        {
            NativeName = "السلطة الفلسطينية",
            EnglishName = "Palestine, State of",
            Iban = new PatternDescriptor(Patterns.PS.Iban)
            {
                Example = "PS92PALS000000000400123456702"
            },
            Bban = new PatternDescriptor(Patterns.PS.Bban, 4)
            {
                Example = "PALS000000000400123456702"
            },
            Bank = new PatternDescriptor(Patterns.PS.Bank, 4)
            {
                Example = "PALS"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "400123456702",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2012, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Portugal
        yield return new IbanCountry("PT")
        {
            NativeName = "Portugal",
            EnglishName = "Portugal",
            Iban = new PatternDescriptor(Patterns.PT.Iban)
            {
                Example = "PT50000201231234567890154"
            },
            Bban = new PatternDescriptor(Patterns.PT.Bban, 4)
            {
                Example = "000201231234567890154"
            },
            Bank = new PatternDescriptor(Patterns.PT.Bank, 4)
            {
                Example = "0002"
            },
            Branch = new PatternDescriptor(Patterns.PT.Branch, 8)
            {
                Example = "0123"
            },
            Sepa = new SepaInfo
            {
                IsMember = true,
                IncludedCountries = ["AZ", "MA"]
            },
            DomesticAccountNumberExample = "0002.0123.12345678901.54",
            LastUpdatedDate = new DateTimeOffset(2024, 7, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Qatar
        yield return new IbanCountry("QA")
        {
            NativeName = "قطر",
            EnglishName = "Qatar",
            Iban = new PatternDescriptor(Patterns.QA.Iban)
            {
                Example = "QA58DOHB00001234567890ABCDEFG"
            },
            Bban = new PatternDescriptor(Patterns.QA.Bban, 4)
            {
                Example = "DOHB00001234567890ABCDEFG"
            },
            Bank = new PatternDescriptor(Patterns.QA.Bank, 4)
            {
                Example = "DOHB"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00001234567890ABCDEFG",
            LastUpdatedDate = new DateTimeOffset(2014, 1, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2014, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Romania
        yield return new IbanCountry("RO")
        {
            NativeName = "România",
            EnglishName = "Romania",
            Iban = new PatternDescriptor(Patterns.RO.Iban)
            {
                Example = "RO49AAAA1B31007593840000"
            },
            Bban = new PatternDescriptor(Patterns.RO.Bban, 4)
            {
                Example = "AAAA1B31007593840000"
            },
            Bank = new PatternDescriptor(Patterns.RO.Bank, 4)
            {
                Example = "AAAA"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "RO49 AAAA 1B31 0075 9384 0000",
            LastUpdatedDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Serbia
        yield return new IbanCountry("RS")
        {
            NativeName = "Srbija",
            EnglishName = "Serbia",
            Iban = new PatternDescriptor(Patterns.RS.Iban)
            {
                Example = "RS35260005601001611379"
            },
            Bban = new PatternDescriptor(Patterns.RS.Bban, 4)
            {
                Example = "260005601001611379"
            },
            Bank = new PatternDescriptor(Patterns.RS.Bank, 4)
            {
                Example = "260"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "260-0056010016113-79",
            LastUpdatedDate = new DateTimeOffset(2017, 3, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Saudi Arabia
        yield return new IbanCountry("SA")
        {
            NativeName = "المملكة العربية السعودية",
            EnglishName = "Saudi Arabia",
            Iban = new PatternDescriptor(Patterns.SA.Iban)
            {
                Example = "SA0380000000608010167519"
            },
            Bban = new PatternDescriptor(Patterns.SA.Bban, 4)
            {
                Example = "80000000608010167519"
            },
            Bank = new PatternDescriptor(Patterns.SA.Bank, 4)
            {
                Example = "80"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "608010167519",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2016, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Seychelles
        yield return new IbanCountry("SC")
        {
            NativeName = "Seychelles",
            EnglishName = "Seychelles",
            Iban = new PatternDescriptor(Patterns.SC.Iban)
            {
                Example = "SC18SSCB11010000000000001497USD"
            },
            Bban = new PatternDescriptor(Patterns.SC.Bban, 4)
            {
                Example = "SSCB11010000000000001497USD"
            },
            Bank = new PatternDescriptor(Patterns.SC.Bank, 4)
            {
                Example = "SSCB11"
            },
            Branch = new PatternDescriptor(Patterns.SC.Branch, 10)
            {
                Example = "01"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0000000000001497",
            LastUpdatedDate = new DateTimeOffset(2019, 10, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2016, 10, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Sudan
        yield return new IbanCountry("SD")
        {
            NativeName = "السودان",
            EnglishName = "Sudan",
            Iban = new PatternDescriptor(Patterns.SD.Iban)
            {
                Example = "SD2129010501234001"
            },
            Bban = new PatternDescriptor(Patterns.SD.Bban, 4)
            {
                Example = "29010501234001"
            },
            Bank = new PatternDescriptor(Patterns.SD.Bank, 4)
            {
                Example = "29"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "010501234001",
            LastUpdatedDate = new DateTimeOffset(2021, 10, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2021, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Sweden
        yield return new IbanCountry("SE")
        {
            NativeName = "Sverige",
            EnglishName = "Sweden",
            Iban = new PatternDescriptor(Patterns.SE.Iban)
            {
                Example = "SE4550000000058398257466"
            },
            Bban = new PatternDescriptor(Patterns.SE.Bban, 4)
            {
                Example = "50000000058398257466"
            },
            Bank = new PatternDescriptor(Patterns.SE.Bank, 4)
            {
                Example = "123"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "1234 12 3456 1",
            LastUpdatedDate = new DateTimeOffset(2009, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Slovenia
        yield return new IbanCountry("SI")
        {
            NativeName = "Slovenija",
            EnglishName = "Slovenia",
            Iban = new PatternDescriptor(Patterns.SI.Iban)
            {
                Example = "SI56263300012039086"
            },
            Bban = new PatternDescriptor(Patterns.SI.Bban, 4)
            {
                Example = "263300012039086"
            },
            Bank = new PatternDescriptor(Patterns.SI.Bank, 4)
            {
                Example = "26330"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "2633 0001 2039 086",
            LastUpdatedDate = new DateTimeOffset(2016, 10, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Slovakia
        yield return new IbanCountry("SK")
        {
            NativeName = "Slovensko",
            EnglishName = "Slovakia",
            Iban = new PatternDescriptor(Patterns.SK.Iban)
            {
                Example = "SK3112000000198742637541"
            },
            Bban = new PatternDescriptor(Patterns.SK.Bban, 4)
            {
                Example = "12000000198742637541"
            },
            Bank = new PatternDescriptor(Patterns.SK.Bank, 4)
            {
                Example = "1200"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "19-8742637541/1200",
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // San Marino
        yield return new IbanCountry("SM")
        {
            NativeName = "San Marino",
            EnglishName = "San Marino",
            Iban = new PatternDescriptor(Patterns.SM.Iban)
            {
                Example = "SM86U0322509800000000270100"
            },
            Bban = new PatternDescriptor(Patterns.SM.Bban, 4)
            {
                Example = "U0322509800000000270100"
            },
            Bank = new PatternDescriptor(Patterns.SM.Bank, 5)
            {
                Example = "03225"
            },
            Branch = new PatternDescriptor(Patterns.SM.Branch, 10)
            {
                Example = "09800"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            LastUpdatedDate = new DateTimeOffset(2016, 8, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 8, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Somalia
        yield return new IbanCountry("SO")
        {
            NativeName = "الصومال",
            EnglishName = "Somalia",
            Iban = new PatternDescriptor(Patterns.SO.Iban)
            {
                Example = "SO211000001001000100141"
            },
            Bban = new PatternDescriptor(Patterns.SO.Bban, 4)
            {
                Example = "1000001001000100141"
            },
            Bank = new PatternDescriptor(Patterns.SO.Bank, 4)
            {
                Example = "1000"
            },
            Branch = new PatternDescriptor(Patterns.SO.Branch, 8)
            {
                Example = "001"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "001000100141",
            LastUpdatedDate = new DateTimeOffset(2023, 2, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2023, 1, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Sao Tome and Principe
        yield return new IbanCountry("ST")
        {
            NativeName = "São Tomé e Príncipe",
            EnglishName = "Sao Tome and Principe",
            Iban = new PatternDescriptor(Patterns.ST.Iban)
            {
                Example = "ST23000100010051845310146"
            },
            Bban = new PatternDescriptor(Patterns.ST.Bban, 4)
            {
                Example = "000100010051845310146"
            },
            Bank = new PatternDescriptor(Patterns.ST.Bank, 4)
            {
                Example = "0001"
            },
            Branch = new PatternDescriptor(Patterns.ST.Branch, 8)
            {
                Example = "0001"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "0051845310146",
            LastUpdatedDate = new DateTimeOffset(2020, 5, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2020, 3, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // El Salvador
        yield return new IbanCountry("SV")
        {
            NativeName = "El Salvador",
            EnglishName = "El Salvador",
            Iban = new PatternDescriptor(Patterns.SV.Iban)
            {
                Example = "SV62CENR00000000000000700025"
            },
            Bban = new PatternDescriptor(Patterns.SV.Bban, 4)
            {
                Example = "CENR00000000000000700025"
            },
            Bank = new PatternDescriptor(Patterns.SV.Bank, 4)
            {
                Example = "CENR"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00000000000000700025",
            LastUpdatedDate = new DateTimeOffset(2021, 3, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2016, 12, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Timor-Leste
        yield return new IbanCountry("TL")
        {
            NativeName = "Timor-Leste",
            EnglishName = "Timor-Leste",
            Iban = new PatternDescriptor(Patterns.TL.Iban)
            {
                Example = "TL380080012345678910157"
            },
            Bban = new PatternDescriptor(Patterns.TL.Bban, 4)
            {
                Example = "0080012345678910157"
            },
            Bank = new PatternDescriptor(Patterns.TL.Bank, 4)
            {
                Example = "008"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "008 00123456789101 57",
            LastUpdatedDate = new DateTimeOffset(2014, 11, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2014, 9, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Tunisia
        yield return new IbanCountry("TN")
        {
            NativeName = "تونس",
            EnglishName = "Tunisia",
            Iban = new PatternDescriptor(Patterns.TN.Iban)
            {
                Example = "TN5910006035183598478831"
            },
            Bban = new PatternDescriptor(Patterns.TN.Bban, 4)
            {
                Example = "10006035183598478831"
            },
            Bank = new PatternDescriptor(Patterns.TN.Bank, 4)
            {
                Example = "10"
            },
            Branch = new PatternDescriptor(Patterns.TN.Branch, 6)
            {
                Example = "006"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "10 006 0351835984788 31",
            LastUpdatedDate = new DateTimeOffset(2016, 5, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Turkey
        yield return new IbanCountry("TR")
        {
            NativeName = "Türkiye",
            EnglishName = "Turkey",
            Iban = new PatternDescriptor(Patterns.TR.Iban)
            {
                Example = "TR330006100519786457841326"
            },
            Bban = new PatternDescriptor(Patterns.TR.Bban, 4)
            {
                Example = "0006100519786457841326"
            },
            Bank = new PatternDescriptor(Patterns.TR.Bank, 4)
            {
                Example = "00061"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2007, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Ukraine
        yield return new IbanCountry("UA")
        {
            NativeName = "Україна",
            EnglishName = "Ukraine",
            Iban = new PatternDescriptor(Patterns.UA.Iban)
            {
                Example = "UA213223130000026007233566001"
            },
            Bban = new PatternDescriptor(Patterns.UA.Bban, 4)
            {
                Example = "3223130000026007233566001"
            },
            Bank = new PatternDescriptor(Patterns.UA.Bank, 4)
            {
                Example = "322313"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "26007233566001",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2016, 2, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Vatican City State
        yield return new IbanCountry("VA")
        {
            NativeName = "Città del Vaticano",
            EnglishName = "Vatican City State",
            Iban = new PatternDescriptor(Patterns.VA.Iban)
            {
                Example = "VA59001123000012345678"
            },
            Bban = new PatternDescriptor(Patterns.VA.Bban, 4)
            {
                Example = "001123000012345678"
            },
            Bank = new PatternDescriptor(Patterns.VA.Bank, 4)
            {
                Example = "001"
            },
            Sepa = new SepaInfo
            {
                IsMember = true
            },
            DomesticAccountNumberExample = "123000012345678",
            LastUpdatedDate = new DateTimeOffset(2018, 12, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2019, 3, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Virgin Islands
        yield return new IbanCountry("VG")
        {
            NativeName = "British Virgin Islands",
            EnglishName = "Virgin Islands",
            Iban = new PatternDescriptor(Patterns.VG.Iban)
            {
                Example = "VG96VPVG0000012345678901"
            },
            Bban = new PatternDescriptor(Patterns.VG.Bban, 4)
            {
                Example = "VPVG0000012345678901"
            },
            Bank = new PatternDescriptor(Patterns.VG.Bank, 4)
            {
                Example = "VPVG"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "00000 12 345 678 901",
            LastUpdatedDate = new DateTimeOffset(2014, 6, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2012, 4, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Kosovo
        yield return new IbanCountry("XK")
        {
            NativeName = "Kosovë",
            EnglishName = "Kosovo",
            Iban = new PatternDescriptor(Patterns.XK.Iban)
            {
                Example = "XK051212012345678906"
            },
            Bban = new PatternDescriptor(Patterns.XK.Bban, 4)
            {
                Example = "1212012345678906"
            },
            Bank = new PatternDescriptor(Patterns.XK.Bank, 4)
            {
                Example = "12"
            },
            Branch = new PatternDescriptor(Patterns.XK.Branch, 6)
            {
                Example = "12"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "1212 0123456789 06",
            LastUpdatedDate = new DateTimeOffset(2016, 9, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2014, 9, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // Yemen
        yield return new IbanCountry("YE")
        {
            NativeName = "اليمن",
            EnglishName = "Yemen",
            Iban = new PatternDescriptor(Patterns.YE.Iban)
            {
                Example = "YE15CBYE0001018861234567891234"
            },
            Bban = new PatternDescriptor(Patterns.YE.Bban, 4)
            {
                Example = "CBYE0001018861234567891234"
            },
            Bank = new PatternDescriptor(Patterns.YE.Bank, 4)
            {
                Example = "CBYE"
            },
            Branch = new PatternDescriptor(Patterns.YE.Branch, 8)
            {
                Example = "0001"
            },
            Sepa = new SepaInfo
            {
                IsMember = false
            },
            DomesticAccountNumberExample = "018861234567891234",
            LastUpdatedDate = new DateTimeOffset(2024, 7, 1, 0, 0, 0, TimeSpan.Zero),
            EffectiveDate = new DateTimeOffset(2024, 7, 1, 0, 0, 0, TimeSpan.Zero)
        };

        // ReSharper restore StringLiteralTypo
        // ReSharper restore CommentTypo
    }

    [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
    private static class Patterns
    {
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal class Pattern : IbanNet.Registry.Patterns.Pattern
        {
            public Pattern(string pattern, int maxLength, bool isFixedLength, PatternToken[] tokens)
                : base(pattern, maxLength, isFixedLength, tokens)
            {
            }
        }

        // Andorra
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("AD2!n4!n4!n12!c", 24, true,
                    [
                        new PatternToken("AD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n4!n12!c", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // United Arab Emirates (The)
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("AE2!n3!n16!n", 23, true,
                    [
                        new PatternToken("AE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n16!n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Albania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("AL2!n8!n16!c", 28, true,
                    [
                        new PatternToken("AL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8!n16!c", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("8!n", 8, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Austria
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("AT2!n5!n11!n", 20, true,
                    [
                        new PatternToken("AT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n11!n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

        }

        // Azerbaijan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class AZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("AZ2!n4!a20!c", 28, true,
                    [
                        new PatternToken("AZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'A'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a20!c", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Bosnia and Herzegovina
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BA2!n3!n3!n8!n2!n", 20, true,
                    [
                        new PatternToken("BA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n3!n8!n2!n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );
        }

        // Belgium
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BE2!n3!n7!n2!n", 16, true,
                    [
                        new PatternToken("BE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 7),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n7!n2!n", 12, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 7),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Bulgaria
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BG2!n4!a4!n2!n8!c", 22, true,
                    [
                        new PatternToken("BG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 8),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a4!n2!n8!c", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 8),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Bahrain
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BH
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BH2!n4!a14!c", 22, true,
                    [
                        new PatternToken("BH"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'H'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a14!c", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 14),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Burundi
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BI2!n5!n5!n11!n2!n", 27, true,
                    [
                        new PatternToken("BI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n5!n11!n2!n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Brazil
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BR2!n8!n5!n10!n1!a1!c", 29, true,
                    [
                        new PatternToken("BR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8!n5!n10!n1!a1!c", 25, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("8!n", 8, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Republic of Belarus
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class BY
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("BY2!n4!c4!n16!c", 28, true,
                    [
                        new PatternToken("BY"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'B'
                        && value[pos++] == 'Y'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!c4!n16!c", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!c", 4, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                    ]
                );

        }

        // Switzerland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CH
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("CH2!n5!n12!c", 21, true,
                    [
                        new PatternToken("CH"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'H'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n12!c", 17, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

        }

        // Costa Rica
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("CR2!n4!n14!n", 22, true,
                    [
                        new PatternToken("CR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n14!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // Cyprus
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CY
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("CY2!n3!n5!n16!c", 28, true,
                    [
                        new PatternToken("CY"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'Y'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n5!n16!c", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Czechia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class CZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("CZ2!n4!n6!n10!n", 24, true,
                    [
                        new PatternToken("CZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'C'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n6!n10!n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // Germany
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("DE2!n8!n10!n", 22, true,
                    [
                        new PatternToken("DE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8!n10!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("8!n", 8, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );

        }

        // Djibouti
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DJ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("DJ2!n5!n5!n11!n2!n", 27, true,
                    [
                        new PatternToken("DJ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'J'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n5!n11!n2!n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Denmark
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("DK2!n4!n9!n1!n", 18, true,
                    [
                        new PatternToken("DK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 9),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n9!n1!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 9),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // Dominican Republic
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class DO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("DO2!n4!c20!n", 28, true,
                    [
                        new PatternToken("DO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'D'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!c20!n", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!c", 4, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                    ]
                );

        }

        // Estonia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class EE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("EE2!n2!n14!n", 20, true,
                    [
                        new PatternToken("EE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'E'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!n14!n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 14),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

        }

        // Egypt
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class EG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("EG2!n4!n4!n17!n", 29, true,
                    [
                        new PatternToken("EG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 17),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'E'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n4!n17!n", 25, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 17),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Spain
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ES
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("ES2!n4!n4!n1!n1!n10!n", 24, true,
                    [
                        new PatternToken("ES"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'E'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n4!n1!n1!n10!n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Finland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("FI2!n3!n11!n", 18, true,
                    [
                        new PatternToken("FI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("6!n8!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("6!n", 6, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                    ]
                );

        }

        // Falkland Islands
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("FK2!n2!a12!n", 18, true,
                    [
                        new PatternToken("FK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!a12!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!a", 2, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                    ]
                );

        }

        // Faroe Islands
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("FO2!n4!n9!n1!n", 18, true,
                    [
                        new PatternToken("FO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 9),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n9!n1!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 9),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // France
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class FR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("FR2!n5!n5!n11!c2!n", 27, true,
                    [
                        new PatternToken("FR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'F'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n5!n11!c2!n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // United Kingdom
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GB
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("GB2!n4!a6!n8!n", 22, true,
                    [
                        new PatternToken("GB"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'B'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a6!n8!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("6!n", 6, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                    ]
                );
        }

        // Georgia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("GE2!n2!a16!n", 22, true,
                    [
                        new PatternToken("GE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!a16!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!a", 2, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 2),
                    ]
                );

        }

        // Gibraltar
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("GI2!n4!a15!c", 23, true,
                    [
                        new PatternToken("GI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a15!c", 19, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 15),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Greenland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("GL2!n4!n9!n1!n", 18, true,
                    [
                        new PatternToken("GL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 9),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n9!n1!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 9),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // Greece
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("GR2!n3!n4!n16!c", 27, true,
                    [
                        new PatternToken("GR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n4!n16!c", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Guatemala
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class GT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("GT2!n4!c20!c", 28, true,
                    [
                        new PatternToken("GT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'G'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!c20!c", 24, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!c", 4, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 4),
                    ]
                );

        }

        // Honduras
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class HN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("HN2!n4!a20!n", 28, true,
                    [
                        new PatternToken("HN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'H'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a20!n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Croatia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class HR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("HR2!n7!n10!n", 21, true,
                    [
                        new PatternToken("HR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 7),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'H'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("7!n10!n", 17, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 7),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("7!n", 7, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 7),
                    ]
                );

        }

        // Hungary
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class HU
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("HU2!n3!n4!n1!n15!n1!n", 28, true,
                    [
                        new PatternToken("HU"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.Digit, 15),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'H'
                        && value[pos++] == 'U'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n4!n1!n15!n1!n", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.Digit, 15),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Ireland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("IE2!n4!a6!n8!n", 22, true,
                    [
                        new PatternToken("IE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a6!n8!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("6!n", 6, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                    ]
                );
        }

        // Israel
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("IL2!n3!n3!n13!n", 23, true,
                    [
                        new PatternToken("IL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n3!n13!n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );
        }

        // Iraq
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IQ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("IQ2!n4!a3!n12!n", 23, true,
                    [
                        new PatternToken("IQ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'Q'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a3!n12!n", 19, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );
        }

        // Iceland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IS
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("IS2!n4!n2!n6!n10!n", 26, true,
                    [
                        new PatternToken("IS"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n2!n6!n10!n", 22, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );
        }

        // Italy
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class IT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("IT2!n1!a5!n5!n12!c", 27, true,
                    [
                        new PatternToken("IT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'I'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("1!a5!n5!n12!c", 23, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Jordan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class JO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("JO2!n4!a4!n18!c", 30, true,
                    [
                        new PatternToken("JO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'J'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a4!n18!c", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Kuwait
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class KW
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("KW2!n4!a22!c", 30, true,
                    [
                        new PatternToken("KW"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 22),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'K'
                        && value[pos++] == 'W'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a22!c", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 22),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Kazakhstan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class KZ
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("KZ2!n3!n13!c", 20, true,
                    [
                        new PatternToken("KZ"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'K'
                        && value[pos++] == 'Z'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n13!c", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Lebanon
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LB
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LB2!n4!n20!c", 28, true,
                    [
                        new PatternToken("LB"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'B'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n20!c", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Saint Lucia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LC
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LC2!n4!a24!c", 32, true,
                    [
                        new PatternToken("LC"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 24),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'C'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a24!c", 28, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 24),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Liechtenstein
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LI2!n5!n12!c", 21, true,
                    [
                        new PatternToken("LI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n12!c", 17, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

        }

        // Lithuania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LT2!n5!n11!n", 20, true,
                    [
                        new PatternToken("LT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n11!n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

        }

        // Luxembourg
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LU
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LU2!n3!n13!c", 20, true,
                    [
                        new PatternToken("LU"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'U'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n13!c", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Latvia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LV
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LV2!n4!a13!c", 21, true,
                    [
                        new PatternToken("LV"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'V'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a13!c", 17, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 13),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Libya
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class LY
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("LY2!n3!n3!n15!n", 25, true,
                    [
                        new PatternToken("LY"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'L'
                        && value[pos++] == 'Y'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n3!n15!n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );
        }

        // Monaco
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MC
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MC2!n5!n5!n11!c2!n", 27, true,
                    [
                        new PatternToken("MC"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'C'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n5!n11!c2!n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Moldova
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MD2!n2!c18!c", 24, true,
                    [
                        new PatternToken("MD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!c18!c", 20, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!c", 2, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 2),
                    ]
                );

        }

        // Montenegro
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ME
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("ME2!n3!n13!n2!n", 22, true,
                    [
                        new PatternToken("ME"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n13!n2!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Macedonia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MK2!n3!n10!c2!n", 19, true,
                    [
                        new PatternToken("MK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n10!c2!n", 15, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Mongolia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MN2!n4!n12!n", 20, true,
                    [
                        new PatternToken("MN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n12!n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // Mauritania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MR2!n5!n5!n11!n2!n", 27, true,
                    [
                        new PatternToken("MR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n5!n11!n2!n", 23, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Malta
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MT2!n4!a5!n18!c", 31, true,
                    [
                        new PatternToken("MT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a5!n18!c", 27, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Mauritius
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class MU
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("MU2!n4!a2!n2!n12!n3!n3!a", 30, true,
                    [
                        new PatternToken("MU"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'M'
                        && value[pos++] == 'U'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a2!n2!n12!n3!n3!a", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("6!c", 6, true,
                    [
                        new PatternToken(AsciiCategory.AlphaNumeric, 6),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );
        }

        // Nicaragua
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("NI2!n4!a20!n", 28, true,
                    [
                        new PatternToken("NI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a20!n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Netherlands (The)
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("NL2!n4!a10!n", 18, true,
                    [
                        new PatternToken("NL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a10!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Norway
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class NO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("NO2!n4!n6!n1!n", 15, true,
                    [
                        new PatternToken("NO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'N'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n6!n1!n", 11, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // Oman
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class OM
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("OM2!n3!n16!c", 23, true,
                    [
                        new PatternToken("OM"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'O'
                        && value[pos++] == 'M'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n16!c", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Pakistan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("PK2!n4!a16!c", 24, true,
                    [
                        new PatternToken("PK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a16!c", 20, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Poland
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("PL2!n8!n16!n", 28, true,
                    [
                        new PatternToken("PL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8!n16!n", 24, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );


            internal static readonly Pattern Branch = new Pattern("8!n", 8, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                    ]
                );
        }

        // Palestine, State of
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PS
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("PS2!n4!a21!c", 29, true,
                    [
                        new PatternToken("PS"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a21!c", 25, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Portugal
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class PT
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("PT2!n4!n4!n11!n2!n", 25, true,
                    [
                        new PatternToken("PT"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'P'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n4!n11!n2!n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // Qatar
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class QA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("QA2!n4!a21!c", 29, true,
                    [
                        new PatternToken("QA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'Q'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a21!c", 25, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 21),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Romania
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class RO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("RO2!n4!a16!c", 24, true,
                    [
                        new PatternToken("RO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'R'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a16!c", 20, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Serbia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class RS
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("RS2!n3!n13!n2!n", 22, true,
                    [
                        new PatternToken("RS"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'R'
                        && value[pos++] == 'S'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n13!n2!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Saudi Arabia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SA2!n2!n18!c", 24, true,
                    [
                        new PatternToken("SA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!n18!c", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

        }

        // Seychelles
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SC
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SC2!n4!a2!n2!n16!n3!a", 31, true,
                    [
                        new PatternToken("SC"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'C'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a2!n2!n16!n3!a", 27, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 16),
                        new PatternToken(AsciiCategory.UppercaseLetter, 3),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a2!n", 6, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );
        }

        // Sudan
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SD
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SD2!n2!n12!n", 18, true,
                    [
                        new PatternToken("SD"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'D'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!n12!n", 14, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

        }

        // Sweden
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SE2!n3!n16!n1!n", 24, true,
                    [
                        new PatternToken("SE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 16),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n16!n1!n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 16),
                        new PatternToken(AsciiCategory.Digit, 1),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Slovenia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SI
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SI2!n5!n8!n2!n", 19, true,
                    [
                        new PatternToken("SI"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'I'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n8!n2!n", 15, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

        }

        // Slovakia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SK2!n4!n6!n10!n", 24, true,
                    [
                        new PatternToken("SK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n6!n10!n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.Digit, 10),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

        }

        // San Marino
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SM
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SM2!n1!a5!n5!n12!c", 27, true,
                    [
                        new PatternToken("SM"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'M'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("1!a5!n5!n12!c", 23, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 1),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.AlphaNumeric, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );
        }

        // Somalia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SO
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SO2!n4!n3!n12!n", 23, true,
                    [
                        new PatternToken("SO"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'O'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n3!n12!n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 12),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );
        }

        // Sao Tome and Principe
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class ST
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("ST2!n8!n11!n2!n", 25, true,
                    [
                        new PatternToken("ST"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'T'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("8!n11!n2!n", 21, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 8),
                        new PatternToken(AsciiCategory.Digit, 11),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }

        // El Salvador
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class SV
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("SV2!n4!a20!n", 28, true,
                    [
                        new PatternToken("SV"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'S'
                        && value[pos++] == 'V'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a20!n", 24, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 20),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Timor-Leste
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TL
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("TL2!n3!n14!n2!n", 23, true,
                    [
                        new PatternToken("TL"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 14),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'L'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n14!n2!n", 19, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 14),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Tunisia
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TN
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("TN2!n2!n3!n13!n2!n", 24, true,
                    [
                        new PatternToken("TN"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'N'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("2!n3!n13!n2!n", 20, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 13),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );
        }

        // Turkey
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class TR
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("TR2!n5!n1!n16!c", 26, true,
                    [
                        new PatternToken("TR"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'T'
                        && value[pos++] == 'R'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("5!n1!n16!c", 22, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                        new PatternToken(AsciiCategory.Digit, 1),
                        new PatternToken(AsciiCategory.AlphaNumeric, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("5!n", 5, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 5),
                    ]
                );

        }

        // Ukraine
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class UA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("UA2!n6!n19!c", 29, true,
                    [
                        new PatternToken("UA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.AlphaNumeric, 19),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'U'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("6!n19!c", 25, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                        new PatternToken(AsciiCategory.AlphaNumeric, 19),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("6!n", 6, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 6),
                    ]
                );

        }

        // Vatican City State
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class VA
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("VA2!n3!n15!n", 22, true,
                    [
                        new PatternToken("VA"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'V'
                        && value[pos++] == 'A'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("3!n15!n", 18, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                        new PatternToken(AsciiCategory.Digit, 15),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("3!n", 3, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 3),
                    ]
                );

        }

        // Virgin Islands
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class VG
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("VG2!n4!a16!n", 24, true,
                    [
                        new PatternToken("VG"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'V'
                        && value[pos++] == 'G'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a16!n", 20, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 16),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

        }

        // Kosovo
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class XK
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("XK2!n4!n10!n2!n", 20, true,
                    [
                        new PatternToken("XK"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'X'
                        && value[pos++] == 'K'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!n10!n2!n", 16, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.Digit, 10),
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("2!n", 2, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 2),
                    ]
                );
        }

        // Yemen
        [GeneratedCode("RegistryProviderTransformGenerator", "2.0")]
        internal static class YE
        {

            internal static readonly Pattern Iban = new IbanImpl();

            private sealed class IbanImpl()
                : Pattern("YE2!n4!a4!n18!c", 30, true,
                    [
                        new PatternToken("YE"),
                        new PatternToken(AsciiCategory.Digit, 2),
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                )
            {
#if USE_SPANS
                internal sealed override bool IsMatch(ReadOnlySpan<char> value, [NotNullWhen(false)] out int? errorPos)
#else
                internal sealed override bool IsMatch(string value, [NotNullWhen(false)] out int? errorPos)
#endif
                {
                    int pos = 0;
                    if (value.Length == MaxLength
                        && value[pos++] == 'Y'
                        && value[pos++] == 'E'
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsUpperAsciiLetter()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAsciiDigit()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        && value[pos++].IsAlphaNumeric()
                        )
                    {
                        errorPos = null;
                        return true;
                    }

                    errorPos = pos - 1;
                    return false;
                }
            }

            internal static readonly Pattern Bban = new Pattern("4!a4!n18!c", 26, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                        new PatternToken(AsciiCategory.Digit, 4),
                        new PatternToken(AsciiCategory.AlphaNumeric, 18),
                    ]
                );

            internal static readonly Pattern Bank = new Pattern("4!a", 4, true,
                    [
                        new PatternToken(AsciiCategory.UppercaseLetter, 4),
                    ]
                );

            internal static readonly Pattern Branch = new Pattern("4!n", 4, true,
                    [
                        new PatternToken(AsciiCategory.Digit, 4),
                    ]
                );
        }
    }
}
